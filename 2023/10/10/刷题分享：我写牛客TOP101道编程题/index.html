<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>刷题分享：我写牛客TOP101道编程题 | 一世逍遥的博客</title><meta name="author" content="LiSheng"><meta name="copyright" content="LiSheng"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="写了也挺久的了吧，今天终于把牛客TOP101道题给写完了，算是有了一些基础编程能力了吧。因为大大小小的事耽误着，其实还写了蛮多天的，写完确实能感觉到有所收获。按时间顺序，也其实就是题目的顺序把剩下的解法都记录在这里。 9月20日 BM 55 没有重复项数字的全排列 url：牛客 BM55 考察知识点：回溯法 做了这题之后我才发现全排列就是原来数组进行两两交换之后的所有结果，当然也可以自己和自己交换">
<meta property="og:type" content="article">
<meta property="og:title" content="刷题分享：我写牛客TOP101道编程题">
<meta property="og:url" content="https://lisheng2001.github.io/2023/10/10/%E5%88%B7%E9%A2%98%E5%88%86%E4%BA%AB%EF%BC%9A%E6%88%91%E5%86%99%E7%89%9B%E5%AE%A2TOP101%E9%81%93%E7%BC%96%E7%A8%8B%E9%A2%98/index.html">
<meta property="og:site_name" content="一世逍遥的博客">
<meta property="og:description" content="写了也挺久的了吧，今天终于把牛客TOP101道题给写完了，算是有了一些基础编程能力了吧。因为大大小小的事耽误着，其实还写了蛮多天的，写完确实能感觉到有所收获。按时间顺序，也其实就是题目的顺序把剩下的解法都记录在这里。 9月20日 BM 55 没有重复项数字的全排列 url：牛客 BM55 考察知识点：回溯法 做了这题之后我才发现全排列就是原来数组进行两两交换之后的所有结果，当然也可以自己和自己交换">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lisheng2001.github.io/images/avatar.webp">
<meta property="article:published_time" content="2023-10-10T13:36:19.000Z">
<meta property="article:modified_time" content="2025-03-28T15:16:42.462Z">
<meta property="article:author" content="LiSheng">
<meta property="article:tag" content="刷编程题">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lisheng2001.github.io/images/avatar.webp"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://lisheng2001.github.io/2023/10/10/%E5%88%B7%E9%A2%98%E5%88%86%E4%BA%AB%EF%BC%9A%E6%88%91%E5%86%99%E7%89%9B%E5%AE%A2TOP101%E9%81%93%E7%BC%96%E7%A8%8B%E9%A2%98/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '刷题分享：我写牛客TOP101道编程题',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-03-28 23:16:42'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/avatar.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">51</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">71</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="一世逍遥的博客"><span class="site-name">一世逍遥的博客</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">刷题分享：我写牛客TOP101道编程题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-10-10T13:36:19.000Z" title="发表于 2023-10-10 21:36:19">2023-10-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-28T15:16:42.462Z" title="更新于 2025-03-28 23:16:42">2025-03-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%88%B7%E9%A2%98/">刷题</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="刷题分享：我写牛客TOP101道编程题"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><p>写了也挺久的了吧，今天终于把牛客TOP101道题给写完了，算是有了一些基础编程能力了吧。因为大大小小的事耽误着，其实还写了蛮多天的，写完确实能感觉到有所收获。按时间顺序，也其实就是题目的顺序把剩下的解法都记录在这里。</p>
<h1 id="月20日">9月20日</h1>
<h2 id="bm-55-没有重复项数字的全排列">BM 55 没有重复项数字的全排列</h2>
<p>url：<a
target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/4bcf3081067a4d028f95acee3ddcd2b1">牛客
BM55</a></p>
<p>考察知识点：回溯法</p>
<p>做了这题之后我才发现全排列就是原来数组进行两两交换之后的所有结果，当然也可以自己和自己交换，这样就是这步操作不改变结果。那第<span
class="math inline">\(i\)</span>次操作时总共有和后面<span
class="math inline">\(n-i+1\)</span>个元素（包括这个元素自己）进行交换的机会。</p>
<p>这个按字典序的意思就是按a-z，0-9的顺序排序，也就是在做之前排序一下元素即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param num int整型一维数组 </span></span><br><span class="line"><span class="comment"># @return int整型二维数组</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permute_item</span>(<span class="params">self, base_num_list: <span class="type">List</span>[<span class="built_in">int</span>], pos: <span class="built_in">int</span>, result: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>):</span><br><span class="line">        <span class="keyword">if</span> pos == <span class="built_in">len</span>(base_num_list)-<span class="number">1</span>:</span><br><span class="line">            <span class="comment"># 这里应该是叶子节点了，准备加入result</span></span><br><span class="line">            result.append(base_num_list)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果不是叶子节点就继续往更深的地方搜索</span></span><br><span class="line">        <span class="comment"># 根据base_num_list和需要变更的位置完成变更        </span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(pos, <span class="built_in">len</span>(base_num_list)):</span><br><span class="line">            <span class="comment"># 自己和自己交换也算一种变更</span></span><br><span class="line">            num_list = base_num_list.copy()</span><br><span class="line">            num_list[pos], num_list[i] = num_list[i], num_list[pos]</span><br><span class="line">            <span class="comment"># 继续往更深的地方搜索</span></span><br><span class="line">            self.permute_item(num_list, pos+<span class="number">1</span>, result)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permute</span>(<span class="params">self , num: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># 用回溯法进行全排列</span></span><br><span class="line">        result = []</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 排序</span></span><br><span class="line">        num.sort()</span><br><span class="line">        self.permute_item(num, <span class="number">0</span>, result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p>用以前学的回溯法框架写了一下，这次不是两两交换，而是逐个加入直到全部加入：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param num int整型一维数组 </span></span><br><span class="line"><span class="comment"># @return int整型二维数组</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    result = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">self, v</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(v) == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;the end...&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">del</span> v[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">advance</span>(<span class="params">self, v</span>):</span><br><span class="line">        <span class="comment"># 因为没有重复数字，因此可以直接进来</span></span><br><span class="line">        visited = <span class="built_in">set</span>(v)</span><br><span class="line">        <span class="keyword">return</span> visited</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_all_next_adj</span>(<span class="params">self, visited, num</span>):</span><br><span class="line">        wait_list = []</span><br><span class="line">        <span class="comment"># 编写新逻辑</span></span><br><span class="line">        <span class="keyword">for</span> i, item <span class="keyword">in</span> <span class="built_in">enumerate</span>(num):</span><br><span class="line">            <span class="keyword">if</span> item <span class="keyword">in</span> visited:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 如果都满足就加入这个下标</span></span><br><span class="line">            wait_list.append(i)</span><br><span class="line">        <span class="comment"># 都不满足就返回None</span></span><br><span class="line">        <span class="keyword">return</span> wait_list</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">self, v, num</span>):</span><br><span class="line">        visited = self.advance(v)</span><br><span class="line">        n = <span class="built_in">len</span>(num)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(v) == <span class="built_in">len</span>(num):</span><br><span class="line">            self.result.append(v.copy())</span><br><span class="line">            <span class="built_in">print</span>(self.result)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 如果不是叶节点就开始回溯法</span></span><br><span class="line">            <span class="comment"># 即深度优先搜索</span></span><br><span class="line">            wait_list = self.get_all_next_adj(visited, num)</span><br><span class="line">            <span class="built_in">print</span>(wait_list)</span><br><span class="line">            e = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> e &lt; <span class="built_in">len</span>(wait_list):</span><br><span class="line">                v.append(num[wait_list[e]])</span><br><span class="line">                self.dfs(v, num)</span><br><span class="line">                e += <span class="number">1</span></span><br><span class="line">        self.backtrack(v)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permute</span>(<span class="params">self , num: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># 用回溯法进行全排列</span></span><br><span class="line">        num.sort()</span><br><span class="line">        self.dfs([], num)</span><br><span class="line">        <span class="keyword">return</span> self.result</span><br></pre></td></tr></table></figure>
<h2 id="bm-56-有重复项的全排列">BM 56 有重复项的全排列</h2>
<p>url：<a
target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/a43a2b986ef34843ac4fdd9159b69863">牛客
BM 56</a></p>
<p>考察知识点：回溯法</p>
<p>似乎之前的BM55没有按字典序排序也过了，但BM56不行。我没想到怎么在中途对结果排序，于是就自己定义了一下比较方法然后在后面自己排序成字典序。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param num int整型一维数组 </span></span><br><span class="line"><span class="comment"># @return int整型二维数组</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    has_visited = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permute_item</span>(<span class="params">self, num: <span class="type">List</span>[<span class="built_in">int</span>], pos: <span class="built_in">int</span>, result: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>):</span><br><span class="line">        <span class="keyword">if</span> pos == <span class="built_in">len</span>(num)-<span class="number">1</span>:</span><br><span class="line">            <span class="comment"># 这里说明是叶子节点了</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;&quot;</span>.join([<span class="built_in">str</span>(n) <span class="keyword">for</span> n <span class="keyword">in</span> num]) <span class="keyword">not</span> <span class="keyword">in</span> self.has_visited:</span><br><span class="line">                <span class="comment"># 如果和之前没有重复就加入</span></span><br><span class="line">                result.append(num.copy())</span><br><span class="line">                self.has_visited.add(<span class="string">&quot;&quot;</span>.join([<span class="built_in">str</span>(n) <span class="keyword">for</span> n <span class="keyword">in</span> num]))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 否则要遍历</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(pos, <span class="built_in">len</span>(num)):</span><br><span class="line">            <span class="comment"># 继续往更深的地方搜索</span></span><br><span class="line">            <span class="keyword">if</span> i != pos <span class="keyword">and</span> num[i] == num[pos]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            num[i], num[pos] = num[pos], num[i]</span><br><span class="line">            self.permute_item(num, pos+<span class="number">1</span>, result)</span><br><span class="line">            num[pos], num[i] = num[i], num[pos]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">compare_result</span>(<span class="params">self, r1: <span class="type">List</span>[<span class="built_in">int</span>], r2: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(r1)):</span><br><span class="line">            <span class="keyword">if</span> r1[i] &lt; r2[i]:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> r1[i] &gt; r2[i]:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sort_to_dict</span>(<span class="params">self, result: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>):</span><br><span class="line">        <span class="comment"># 用冒泡/选择排序</span></span><br><span class="line">        N = <span class="built_in">len</span>(result)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">            min_ = i</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, N):</span><br><span class="line">                <span class="keyword">if</span> self.compare_result(result[j], result[min_]):</span><br><span class="line">                    min_ = j</span><br><span class="line">            result[min_], result[i] = result[i], result[min_]</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permuteUnique</span>(<span class="params">self , num: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        num.sort()</span><br><span class="line">        self.has_visited = <span class="built_in">set</span>()</span><br><span class="line">        result = []</span><br><span class="line">        self.permute_item(num, <span class="number">0</span>, result)</span><br><span class="line">        <span class="keyword">return</span> self.sort_to_dict(result)</span><br></pre></td></tr></table></figure>
<p>能不能用列表自带的sort进行排序，然后指定比较接口呢？是可以的，但是有点烦，因为原来的key虽然支持传入函数，但是这个key的函数是要求在对元素计算一个可比较的数，要传入比较接口有两种办法，一种就是我们自己包装一下要比较的元素（我更推荐这种做法，因为后面字典也会要用到__hash__和__eq__来计算哈希值）。另一种就是用Python在functools里提供的cmp_to_key完成。第二种方法演示如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param num int整型一维数组 </span></span><br><span class="line"><span class="comment"># @return int整型二维数组</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> cmp_to_key</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compare_result</span>(<span class="params">r1: <span class="type">List</span>[<span class="built_in">int</span>], r2: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(r1)):</span><br><span class="line">        <span class="keyword">if</span> r1[i] &lt; r2[i]:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> r1[i] &gt; r2[i]:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    has_visited = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permute_item</span>(<span class="params">self, num: <span class="type">List</span>[<span class="built_in">int</span>], pos: <span class="built_in">int</span>, result: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>):</span><br><span class="line">        <span class="keyword">if</span> pos == <span class="built_in">len</span>(num)-<span class="number">1</span>:</span><br><span class="line">            <span class="comment"># 这里说明是叶子节点了</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;&quot;</span>.join([<span class="built_in">str</span>(n) <span class="keyword">for</span> n <span class="keyword">in</span> num]) <span class="keyword">not</span> <span class="keyword">in</span> self.has_visited:</span><br><span class="line">                <span class="comment"># 如果和之前没有重复就加入</span></span><br><span class="line">                result.append(num.copy())</span><br><span class="line">                self.has_visited.add(<span class="string">&quot;&quot;</span>.join([<span class="built_in">str</span>(n) <span class="keyword">for</span> n <span class="keyword">in</span> num]))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 否则要遍历</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(pos, <span class="built_in">len</span>(num)):</span><br><span class="line">            <span class="comment"># 继续往更深的地方搜索</span></span><br><span class="line">            <span class="keyword">if</span> i != pos <span class="keyword">and</span> num[i] == num[pos]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            num[i], num[pos] = num[pos], num[i]</span><br><span class="line">            self.permute_item(num, pos+<span class="number">1</span>, result)</span><br><span class="line">            num[pos], num[i] = num[i], num[pos]</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permuteUnique</span>(<span class="params">self , num: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        num.sort()</span><br><span class="line">        self.has_visited = <span class="built_in">set</span>()</span><br><span class="line">        result = []</span><br><span class="line">        self.permute_item(num, <span class="number">0</span>, result)</span><br><span class="line">        result.sort(key=cmp_to_key(compare_result))</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h2 id="bm-57-岛屿数量">BM 57 岛屿数量</h2>
<p>url：<a
target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/0c9664d1554e466aa107d899418e814e">牛客
BM57</a></p>
<p>考察知识点：回溯法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 判断岛屿数量</span></span><br><span class="line"><span class="comment"># @param grid char字符型二维数组 </span></span><br><span class="line"><span class="comment"># @return int整型</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">solve</span>(<span class="params">self , grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        num_of_island = <span class="number">0</span></span><br><span class="line">        n = <span class="built_in">len</span>(grid)</span><br><span class="line">        m = <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]], i: <span class="built_in">int</span>, j: <span class="built_in">int</span></span>):</span><br><span class="line">            <span class="comment"># 将该位置置为0</span></span><br><span class="line">            grid[i][j] = <span class="string">&quot;0&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 向上下左右四个方向搜索</span></span><br><span class="line">            <span class="keyword">if</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> grid[i][j-<span class="number">1</span>] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                dfs(grid, i, j-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> j &lt; m-<span class="number">1</span> <span class="keyword">and</span> grid[i][j+<span class="number">1</span>] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                dfs(grid, i, j+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> grid[i-<span class="number">1</span>][j] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                dfs(grid, i-<span class="number">1</span>, j)</span><br><span class="line">            <span class="keyword">if</span> i &lt; n-<span class="number">1</span> <span class="keyword">and</span> grid[i+<span class="number">1</span>][j] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                dfs(grid, i+<span class="number">1</span>, j)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> l1 <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> l2 <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">                <span class="keyword">if</span> grid[l1][l2] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                    num_of_island += <span class="number">1</span></span><br><span class="line">                    dfs(grid, l1, l2)</span><br><span class="line">        <span class="keyword">return</span> num_of_island</span><br></pre></td></tr></table></figure>
<h2 id="bm-58-字符串的排列">BM 58 字符串的排列</h2>
<p>url：<a
target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/fe6b651b66ae47d7acce78ffdd9a96c7">牛客
BM58</a></p>
<p>考察知识点：回溯法、排列问题</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param str string字符串 </span></span><br><span class="line"><span class="comment"># @return string字符串一维数组</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Permutation</span>(<span class="params">self , <span class="built_in">str</span>: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        str_list = <span class="built_in">list</span>(<span class="built_in">str</span>)</span><br><span class="line">        N = <span class="built_in">len</span>(str_list)</span><br><span class="line">        result = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">str_list: <span class="type">List</span>[<span class="built_in">str</span>], pos: <span class="built_in">int</span>, result</span>):</span><br><span class="line">            <span class="keyword">if</span> pos == N - <span class="number">1</span>:</span><br><span class="line">                target = <span class="string">&quot;&quot;</span>.join(str_list)</span><br><span class="line">                result.add(target)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 深度优先搜索</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(pos, N):</span><br><span class="line">                <span class="comment"># 交换</span></span><br><span class="line">                str_list[i], str_list[pos] = str_list[pos], str_list[i]</span><br><span class="line">                dfs(str_list, pos+<span class="number">1</span>, result)</span><br><span class="line">                <span class="comment"># 回溯</span></span><br><span class="line">                str_list[pos], str_list[i] = str_list[i], str_list[pos]</span><br><span class="line">        </span><br><span class="line">        dfs(str_list, <span class="number">0</span>, result)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(result)</span><br></pre></td></tr></table></figure>
<h2 id="bm-59-n皇后问题">BM 59 N皇后问题</h2>
<p>url：<a
target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/c76408782512486d91eea181107293b6">牛客
BM59</a></p>
<p>考察知识点：回溯法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param n int整型 the n</span></span><br><span class="line"><span class="comment"># @return int整型</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Nqueen</span>(<span class="params">self , n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># 回溯法求解N皇后问题</span></span><br><span class="line">        num_of_solution = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">exceedBound</span>(<span class="params">col: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">            <span class="comment"># 检查当前是否越界</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(col) &lt;= <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 检查新皇后是否越界</span></span><br><span class="line">                q2 = [<span class="built_in">len</span>(col)-<span class="number">1</span>, col[-<span class="number">1</span>]]</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(col)-<span class="number">1</span>):</span><br><span class="line">                    q1 = [i, col[i]]</span><br><span class="line">                    <span class="comment"># 检查对角线（列和行在之前检查过了）</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">abs</span>(q1[<span class="number">0</span>] - q2[<span class="number">0</span>]) == <span class="built_in">abs</span>(q1[<span class="number">1</span>] - q2[<span class="number">1</span>]):</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">col: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">            <span class="keyword">nonlocal</span> num_of_solution, n</span><br><span class="line">            <span class="comment"># 检查当前解是否是叶子节点</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(col) == n:</span><br><span class="line">                num_of_solution += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 这边还不是叶子节点，因此需要落子</span></span><br><span class="line">                j = <span class="number">0</span></span><br><span class="line">                <span class="keyword">while</span> j &lt; n:</span><br><span class="line">                    <span class="keyword">if</span> j <span class="keyword">in</span> col:</span><br><span class="line">                        j += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> exceedBound(col + [j]):</span><br><span class="line">                        <span class="comment"># 落子并继续深度搜索</span></span><br><span class="line">                        col.append(j)</span><br><span class="line">                        dfs(col)</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 回溯</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(col) &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">del</span> col[-<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        dfs([])</span><br><span class="line">        <span class="keyword">return</span> num_of_solution</span><br></pre></td></tr></table></figure>
<h2 id="bm-60-括号生成">BM 60 括号生成</h2>
<p>url：<a
target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/c9addb265cdf4cdd92c092c655d164ca">牛客
BM60</a></p>
<p>考察知识点：回溯法、栈</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param n int整型 </span></span><br><span class="line"><span class="comment"># @return string字符串一维数组</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generateParenthesis</span>(<span class="params">self , n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        str_list = []</span><br><span class="line">        result = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">isValid</span>(<span class="params">str_list</span>):</span><br><span class="line">            <span class="comment"># 检查符号串是否合法</span></span><br><span class="line">            stack = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(str_list)):</span><br><span class="line">                <span class="keyword">if</span> str_list[i] == <span class="string">&quot;(&quot;</span>:</span><br><span class="line">                    stack.append(<span class="string">&quot;(&quot;</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> <span class="keyword">and</span> stack[-<span class="number">1</span>] == <span class="string">&quot;(&quot;</span>:</span><br><span class="line">                        stack.pop()</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="comment"># 这里是出问题了，所以不合法</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">str_list, r_num</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(str_list) == <span class="number">2</span> * n:</span><br><span class="line">                <span class="comment"># 叶子节点</span></span><br><span class="line">                result.append(<span class="string">&quot;&quot;</span>.join(str_list))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 深度优先搜索</span></span><br><span class="line">                next_list = [<span class="string">&quot;(&quot;</span>, <span class="string">&quot;)&quot;</span>]</span><br><span class="line">                <span class="keyword">for</span> item <span class="keyword">in</span> next_list:</span><br><span class="line">                    <span class="keyword">if</span> isValid(str_list + [item]):</span><br><span class="line">                        <span class="keyword">if</span> item == <span class="string">&quot;(&quot;</span>:</span><br><span class="line">                            <span class="keyword">if</span> r_num + <span class="number">1</span> &gt; n:</span><br><span class="line">                                <span class="keyword">continue</span></span><br><span class="line">                            str_list.append(item)</span><br><span class="line">                            dfs(str_list, r_num+<span class="number">1</span>)</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            str_list.append(item)</span><br><span class="line">                            dfs(str_list, r_num)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 回溯</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(str_list) &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">del</span> str_list[-<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        dfs([], <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h1 id="月21日">9月21日</h1>
<h2 id="bm-61-矩阵最长递增路径">BM 61 矩阵最长递增路径</h2>
<p>url：<a
target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/7a71a88cdf294ce6bdf54c899be967a2">牛客
BM61</a></p>
<p>考察知识点：回溯法、动态规划</p>
<p>先来一个暴力回溯的方法，这个方法从起点一直找递增路径，然后保存最长递增路径的长度并返回。复杂度很高，过不了所有的用例。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 递增路径的最大长度</span></span><br><span class="line"><span class="comment"># @param matrix int整型二维数组 描述矩阵的每个数</span></span><br><span class="line"><span class="comment"># @return int整型</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">solve</span>(<span class="params">self , matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        n = <span class="built_in">len</span>(matrix)</span><br><span class="line">        m = <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        max_path_length = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">isLeaf</span>(<span class="params">v</span>):</span><br><span class="line">            <span class="comment"># 判断是不是叶节点，主要看还有没有路可走</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(v) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            now_i, now_j = v[-<span class="number">1</span>]</span><br><span class="line">            now_v = matrix[now_i][now_j]</span><br><span class="line">            <span class="keyword">if</span> now_i &gt; <span class="number">0</span> <span class="keyword">and</span> matrix[now_i-<span class="number">1</span>][now_j] &gt; now_v:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">elif</span> now_j &gt; <span class="number">0</span> <span class="keyword">and</span> matrix[now_i][now_j-<span class="number">1</span>] &gt; now_v:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">elif</span> now_i &lt; n-<span class="number">1</span> <span class="keyword">and</span> matrix[now_i+<span class="number">1</span>][now_j] &gt; now_v:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">elif</span> now_j &lt; m-<span class="number">1</span> <span class="keyword">and</span> matrix[now_i][now_j+<span class="number">1</span>] &gt; now_v:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">all_next_point</span>(<span class="params">v</span>):</span><br><span class="line">            points = []</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(v) == <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 如果没选择任何节点，那就可以从任意点出发</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">                        points.append([i, j])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 取出现在的点</span></span><br><span class="line">                now_i, now_j = v[-<span class="number">1</span>]</span><br><span class="line">                now_v = matrix[now_i][now_j]</span><br><span class="line">                <span class="comment"># 判断上下左右的值与现在点的关系</span></span><br><span class="line">                <span class="keyword">if</span> now_i &gt; <span class="number">0</span> <span class="keyword">and</span> matrix[now_i-<span class="number">1</span>][now_j] &gt; now_v:</span><br><span class="line">                    points.append([now_i-<span class="number">1</span>, now_j])</span><br><span class="line">                <span class="keyword">if</span> now_j &gt; <span class="number">0</span> <span class="keyword">and</span> matrix[now_i][now_j-<span class="number">1</span>] &gt; now_v:</span><br><span class="line">                    points.append([now_i, now_j-<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">if</span> now_i &lt; n-<span class="number">1</span> <span class="keyword">and</span> matrix[now_i+<span class="number">1</span>][now_j] &gt; now_v:</span><br><span class="line">                    points.append([now_i+<span class="number">1</span>, now_j])</span><br><span class="line">                <span class="keyword">if</span> now_j &lt; m-<span class="number">1</span> <span class="keyword">and</span> matrix[now_i][now_j+<span class="number">1</span>] &gt; now_v:</span><br><span class="line">                    points.append([now_i, now_j+<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> points</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">v</span>):</span><br><span class="line">            <span class="keyword">nonlocal</span> max_path_length</span><br><span class="line">            <span class="keyword">if</span> isLeaf(v):</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(v) &gt; max_path_length:</span><br><span class="line">                    max_path_length = <span class="built_in">len</span>(v)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 深度优先搜索</span></span><br><span class="line">                points = all_next_point(v)</span><br><span class="line">                <span class="keyword">for</span> point <span class="keyword">in</span> points:</span><br><span class="line">                    <span class="comment"># 之前判断过是否可行，因此不需要检查边界</span></span><br><span class="line">                    v.append(point)</span><br><span class="line">                    dfs(v)</span><br><span class="line">            <span class="comment"># 回溯</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(v) &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">del</span> v[-<span class="number">1</span>]</span><br><span class="line">        dfs([])</span><br><span class="line">        <span class="keyword">return</span> max_path_length</span><br></pre></td></tr></table></figure>
<p>动态规划可以做这题。原因是地图确定后，从某个点出发能到达的最长路径值是固定的，而且和从哪来的没关系。这就使得这个问题具有最优子结构性质，即最优解中也存在所有子问题的最优解。比如一个路径是"1-&gt;3-&gt;5"是最长递增路径，那么从"1-&gt;3"和"3-&gt;5"必不可能存在更长的递增路径了，否则原路径就不是最长递增路径。通过这个性质我们可以把这个问题抽象为从一个点出发的最长路径是所有下一个能访问点的最长路径长度加一的最大值，用程序可以表示为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 递增路径的最大长度</span></span><br><span class="line"><span class="comment"># @param matrix int整型二维数组 描述矩阵的每个数</span></span><br><span class="line"><span class="comment"># @return int整型</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">solve</span>(<span class="params">self , matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        n = <span class="built_in">len</span>(matrix)</span><br><span class="line">        m = <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m)] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        next_ij = [(-<span class="number">1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, -<span class="number">1</span>), (<span class="number">0</span>, <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i, j</span>):</span><br><span class="line">            <span class="keyword">if</span> dp[i][j] != <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> dp[i][j]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 访问之后最小长度应该是1</span></span><br><span class="line">            dp[i][j] += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 否则就递归计算该点出发的最长递增路径长度</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">                next_i = i + next_ij[k][<span class="number">0</span>]</span><br><span class="line">                next_j = j + next_ij[k][<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> next_i &gt;= <span class="number">0</span> <span class="keyword">and</span> next_i &lt; n <span class="keyword">and</span> \</span><br><span class="line">                    next_j &gt;= <span class="number">0</span> <span class="keyword">and</span> next_j &lt; m <span class="keyword">and</span> \</span><br><span class="line">                    matrix[next_i][next_j] &gt; matrix[i][j]:</span><br><span class="line">                    <span class="comment"># 看看哪个更大</span></span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dfs(next_i, next_j)+<span class="number">1</span>, dp[i][j])</span><br><span class="line">            <span class="keyword">return</span> dp[i][j]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">                dfs(i, j)</span><br><span class="line">        <span class="built_in">print</span>(dp)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">map</span>(<span class="built_in">max</span>, dp))</span><br></pre></td></tr></table></figure>
<h2 id="bm-62-斐波拉契数列">BM 62 斐波拉契数列</h2>
<p>url：<a
target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3">牛客
BM62</a></p>
<p>考察知识点：动态规划</p>
<p>非常经典的一道题，其递归表达式就说明非常适合动态规划求解。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param n int整型 </span></span><br><span class="line"><span class="comment"># @return int整型</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Fibonacci</span>(<span class="params">self , n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> i == <span class="number">1</span>:</span><br><span class="line">                dp[i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h2 id="bm-63-跳台阶">BM 63 跳台阶</h2>
<p>url：<a
target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4">牛客
BM63</a></p>
<p>考察知识点：动态规划</p>
<p>这种题目就可以反着思考，比如我在离终点一格的地方有几种跳法呢，那就一种对吧，离终点两格的地方有2种跳法。那我要跳到离终点一格或者两格近的地方需要有几种跳法，这样递归思考，之后总跳法是各种跳法的和。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param number int整型 </span></span><br><span class="line"><span class="comment"># @return int整型</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">jumpFloor</span>(<span class="params">self , number: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(number)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">jump</span>(<span class="params">k: <span class="built_in">int</span>, number: <span class="built_in">int</span></span>):</span><br><span class="line">            <span class="comment"># k是当前位置, number是目标位置</span></span><br><span class="line">            <span class="keyword">if</span> dp[k] != <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> dp[k]</span><br><span class="line"></span><br><span class="line">            diff = number - k</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> diff &lt;= <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">elif</span> diff == <span class="number">1</span>:</span><br><span class="line">                dp[k] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> diff == <span class="number">2</span>:</span><br><span class="line">                dp[k] = <span class="number">2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 不是1或者2就要递归</span></span><br><span class="line">                dp[k] = jump(k+<span class="number">1</span>, number) + jump(k+<span class="number">2</span>, number)</span><br><span class="line">            <span class="keyword">return</span> dp[k]</span><br><span class="line">        </span><br><span class="line">        jump(<span class="number">0</span>, number)</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h2 id="bm-64-最小花费爬楼梯">BM 64 最小花费爬楼梯</h2>
<p>url：<a
target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/6fe0302a058a4e4a834ee44af88435c7">牛客
BM64</a></p>
<p>考察知识点：动态规划</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param cost int整型一维数组 </span></span><br><span class="line"><span class="comment"># @return int整型</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minCostClimbingStairs</span>(<span class="params">self , cost: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        n = <span class="built_in">len</span>(cost)</span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">climb</span>(<span class="params">k: <span class="built_in">int</span></span>):</span><br><span class="line">            <span class="keyword">if</span> dp[k] != <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> dp[k]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 计算爬到第k阶最少要多少花费</span></span><br><span class="line">            <span class="keyword">if</span> k == <span class="number">0</span> <span class="keyword">or</span> k == <span class="number">1</span>:</span><br><span class="line">                <span class="comment"># 可以从一节或者二阶开始爬</span></span><br><span class="line">                dp[k] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[k] = <span class="built_in">min</span>(climb(k-<span class="number">1</span>) + cost[k-<span class="number">1</span>], climb(k-<span class="number">2</span>) + cost[k-<span class="number">2</span>])</span><br><span class="line">            <span class="keyword">return</span> dp[k]</span><br><span class="line">        <span class="keyword">return</span> climb(n)</span><br></pre></td></tr></table></figure>
<h2 id="bm-65-最长公共子序列二">BM 65 最长公共子序列（二）</h2>
<p>url：<a
target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/6d29638c85bb4ffd80c020fe244baf11">牛客
BM65</a></p>
<p>考察知识点：动态规划、最长公共子序列</p>
<p>感觉可以写个专题，因为确实有点东西。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># longest common subsequence</span></span><br><span class="line"><span class="comment"># @param s1 string字符串 the string</span></span><br><span class="line"><span class="comment"># @param s2 string字符串 the string</span></span><br><span class="line"><span class="comment"># @return string字符串</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">LCS</span>(<span class="params">self , s1: <span class="built_in">str</span>, s2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        n = <span class="built_in">len</span>(s1)</span><br><span class="line">        m = <span class="built_in">len</span>(s2)</span><br><span class="line">        dp = [[<span class="number">0</span>]*(m+<span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">                <span class="comment"># 判断字符是否在最长子序列中</span></span><br><span class="line">                <span class="keyword">if</span> s1[i-<span class="number">1</span>] == s2[j-<span class="number">1</span>]:</span><br><span class="line">                    <span class="comment"># 该字符一定在最长子序列中</span></span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 如果不等的话有3种情况，</span></span><br><span class="line">                    <span class="comment"># s1[i]是、s2[j]是或者两者都不是</span></span><br><span class="line">                    <span class="comment"># 第三种情况可以被前两种组合表示</span></span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j-<span class="number">1</span>], dp[i-<span class="number">1</span>][j])</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 通过回溯构造解</span></span><br><span class="line">        i, j = n, m</span><br><span class="line">        k = dp[i][j]</span><br><span class="line">        lcs = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">while</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> k &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">while</span> dp[i][j] == dp[i-<span class="number">1</span>][j] <span class="keyword">and</span> i &gt; <span class="number">0</span>:</span><br><span class="line">                i = i - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> dp[i][j] == dp[i][j-<span class="number">1</span>] <span class="keyword">and</span> j &gt; <span class="number">0</span>:</span><br><span class="line">                j = j - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            lcs = s1[i-<span class="number">1</span>] + lcs</span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">            k -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> lcs <span class="keyword">if</span> lcs <span class="keyword">else</span> <span class="string">&quot;-1&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="bm-66-最长公共子串">BM 66 最长公共子串</h2>
<p>url：<a
target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/f33f5adc55f444baa0e0ca87ad8a6aac">牛客
BM66</a></p>
<p>考察知识点：动态规划</p>
<p>家人们谁懂啊，同样的算法就Python超时...</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># longest common substring</span></span><br><span class="line"><span class="comment"># @param str1 string字符串 the string</span></span><br><span class="line"><span class="comment"># @param str2 string字符串 the string</span></span><br><span class="line"><span class="comment"># @return string字符串</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">LCS</span>(<span class="params">self , str1: <span class="built_in">str</span>, str2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        n = <span class="built_in">len</span>(str1)</span><br><span class="line">        m = <span class="built_in">len</span>(str2)</span><br><span class="line"></span><br><span class="line">        dp = [[<span class="number">0</span>]*(m+<span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 回溯构造最长公共字串</span></span><br><span class="line">        max_, max_i = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> str1[i-<span class="number">1</span>] == str2[j-<span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> dp[i][j] &gt; max_:</span><br><span class="line">                        max_i = i</span><br><span class="line">                        max_ = dp[i][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 不等的话怎么办呢</span></span><br><span class="line">                    <span class="comment"># 可能是位置没对齐之类的，但似乎不用管</span></span><br><span class="line">                    <span class="keyword">pass</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> str1[max_i-max_: max_i]</span><br></pre></td></tr></table></figure>
<p>官方提供的非动态规划版本，理论时间复杂度是<span
class="math inline">\(O(m^2n)\)</span>，但是却能过...</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># longest common substring</span></span><br><span class="line"><span class="comment"># @param str1 string字符串 the string</span></span><br><span class="line"><span class="comment"># @param str2 string字符串 the string</span></span><br><span class="line"><span class="comment"># @return string字符串</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">LCS</span>(<span class="params">self , str1: <span class="built_in">str</span>, str2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment">#让str1为较长的字符串</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(str1) &lt; <span class="built_in">len</span>(str2):</span><br><span class="line">            str1, str2 = str2, str1</span><br><span class="line">        res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        max_len = <span class="number">0</span></span><br><span class="line">        <span class="comment">#遍历str1的长度</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(str1)):</span><br><span class="line">            <span class="comment">#查找是否存在</span></span><br><span class="line">            <span class="keyword">if</span> str1[i - max_len : i + <span class="number">1</span>] <span class="keyword">in</span> str2:</span><br><span class="line">                res = str1[i - max_len : i + <span class="number">1</span>]</span><br><span class="line">                max_len += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h2 id="bm-67-不同路径的数目一">BM 67 不同路径的数目（一）</h2>
<p>url：<a
target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/166eaff8439d4cd898e3ba933fbc6358">牛客
BM67</a></p>
<p>考察知识点：排列组合、动态规划</p>
<p>这道题还是有点意思，直接从左上角移动到右下角，只能进行向下或者向右的操作。路径的数目只和向下和向右的组合顺序有关，对于<span
class="math inline">\(m*n\)</span>的图，向下操作要进行<span
class="math inline">\(m-1\)</span>次，向右操作要进行<span
class="math inline">\(n-1\)</span>次。所以路径总数相当于把<span
class="math inline">\(m-1\)</span>个小球放入<span
class="math inline">\(m-n-2\)</span>个位置里，即有： <span
class="math display">\[
C_{m-n-2}^{m-1}=\frac{(m-n-2)!}{(m-1)!(n-1)!}
\]</span> 种不同的路径。</p>
<p>写代码实现如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param m int整型 </span></span><br><span class="line"><span class="comment"># @param n int整型 </span></span><br><span class="line"><span class="comment"># @return int整型</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">uniquePaths</span>(<span class="params">self , m: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">import</span> math</span><br><span class="line">        <span class="keyword">return</span> math.factorial(m+n-<span class="number">2</span>) // (math.factorial(m-<span class="number">1</span>) * math.factorial(n-<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p>如果要用动态规划老实操作呢，也可以做到。需要注意的是从出生点开始走只有1种走法，然后如果走到一个点那个点的走法种数是其左边和上边的走法之和。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param m int整型 </span></span><br><span class="line"><span class="comment"># @param n int整型 </span></span><br><span class="line"><span class="comment"># @return int整型</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">uniquePaths</span>(<span class="params">self , m: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        dp = [[<span class="number">1</span>]*n <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> j &gt; <span class="number">0</span>:</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i][j-<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">elif</span> i &gt; <span class="number">0</span>:</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j]</span><br><span class="line">                <span class="keyword">elif</span> j &gt; <span class="number">0</span>:</span><br><span class="line">                    dp[i][j] = dp[i][j-<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h1 id="月22日">9月22日</h1>
<h2 id="bm-68-矩阵最小路径和">BM 68 矩阵最小路径和</h2>
<p>url：<a
target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/7d21b6be4c6b429bb92d219341c4f8bb">牛客
BM68</a></p>
<p>考察知识点：动态规划</p>
<p>和BM67类似，理清动态规划的递推关系即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param matrix int整型二维数组 the matrix</span></span><br><span class="line"><span class="comment"># @return int整型</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minPathSum</span>(<span class="params">self , matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        n = <span class="built_in">len</span>(matrix)</span><br><span class="line">        m = <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        dp = [[<span class="number">0</span>]*m <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">and</span> j == <span class="number">0</span>:</span><br><span class="line">                    dp[i][j] = matrix[i][j]</span><br><span class="line">                <span class="keyword">elif</span> i == <span class="number">0</span>:</span><br><span class="line">                    dp[i][j] = dp[i][j-<span class="number">1</span>] + matrix[i][j]</span><br><span class="line">                <span class="keyword">elif</span> j == <span class="number">0</span>:</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j] + matrix[i][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 是上方和左方的最小值加上该点花费</span></span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]) + matrix[i][j]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>][m-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h2 id="bm-69-把数字翻译成字符串">BM 69 把数字翻译成字符串</h2>
<p>url：<a
target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/046a55e6cd274cffb88fc32dba695668">牛客
BM69</a></p>
<p>考察知识点：动态规划</p>
<p>这个题目是很体现重叠子问题的一道题，不管先解码1个字符两次或者一次解码2个字符，后面的字符都一样而且需要多次解码。如果能集下后面字符的解码结果就能大大加速计算速度。可以用一个字典保存已经解码过的字符串从而避免重复解决重叠子问题。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 解码</span></span><br><span class="line"><span class="comment"># @param nums string字符串 数字串</span></span><br><span class="line"><span class="comment"># @return int整型</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">solve</span>(<span class="params">self , nums: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        dp = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">decode</span>(<span class="params">s</span>):</span><br><span class="line">            <span class="comment"># 返回译码种数</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> s[<span class="number">0</span>] != <span class="string">&quot;0&quot;</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">len</span>(s) == <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">if</span> s[<span class="number">0</span>] == <span class="string">&quot;0&quot;</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">                <span class="keyword">elif</span> <span class="built_in">int</span>(s) &lt;= <span class="number">26</span>:</span><br><span class="line">                    <span class="keyword">if</span> s[<span class="number">1</span>] != <span class="string">&quot;0&quot;</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> <span class="built_in">int</span>(s) &gt; <span class="number">26</span>:</span><br><span class="line">                    <span class="keyword">if</span> s[<span class="number">1</span>] != <span class="string">&quot;0&quot;</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 大于2的情况</span></span><br><span class="line">                prefix = s[:<span class="number">2</span>]</span><br><span class="line">                num = <span class="number">0</span></span><br><span class="line">                <span class="keyword">if</span> s <span class="keyword">in</span> dp:</span><br><span class="line">                    <span class="keyword">return</span> dp[s]</span><br><span class="line">                <span class="keyword">if</span> prefix[<span class="number">0</span>] == <span class="string">&quot;0&quot;</span>:</span><br><span class="line">                    num = <span class="number">0</span></span><br><span class="line">                <span class="keyword">elif</span> <span class="built_in">int</span>(prefix) &lt;= <span class="number">26</span>:</span><br><span class="line">                    <span class="keyword">if</span> prefix[<span class="number">1</span>] == <span class="string">&quot;0&quot;</span>:</span><br><span class="line">                        num = decode(s[<span class="number">2</span>:])</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        num = decode(s[<span class="number">2</span>:]) + decode(s[<span class="number">1</span>:])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    num = decode(s[<span class="number">1</span>:])</span><br><span class="line">                <span class="comment"># 记录</span></span><br><span class="line">                dp[s] = num</span><br><span class="line">                <span class="keyword">return</span> num</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> decode(nums)</span><br></pre></td></tr></table></figure>
<p>看了题解，貌似题解还有问题，解码“120”的时候官方的题解结果是2，但实际是1。其原因就是当前数字是"0"是一个特殊的分支，它要单独考虑，看了评论区的一个题解不错，注释也挺清楚，贴上来：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 解码</span></span><br><span class="line"><span class="comment"># @param nums string字符串 数字串</span></span><br><span class="line"><span class="comment"># @return int整型</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">solve</span>(<span class="params">self , nums: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        l = <span class="built_in">len</span>(nums)</span><br><span class="line">        dp = [<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(l+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, l+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">1</span>:</span><br><span class="line">                <span class="comment"># 如果第一个数字是0，不存在可行的翻译</span></span><br><span class="line">                <span class="keyword">if</span> nums[i-<span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 任何一个’0‘，都依赖于其前面一个数字，先讨论当前数字为0的情况</span></span><br><span class="line">                <span class="keyword">if</span> nums[i-<span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">                    <span class="comment"># 如果当前0不能和前一个数字组合</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">int</span>(nums[i-<span class="number">2</span>]) &gt; <span class="number">2</span> <span class="keyword">or</span> nums[i-<span class="number">2</span>] == <span class="string">&#x27;0&#x27;</span>):</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">                    <span class="comment"># 当前0和前一个数字组合</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dp[i] = dp[i-<span class="number">2</span>]</span><br><span class="line">                <span class="comment"># 再讨论当前数字不为0的情况</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 如果当前数字不能和前一个数字组合</span></span><br><span class="line">                    <span class="keyword">if</span> nums[i-<span class="number">2</span>] == <span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> <span class="built_in">int</span>(nums[i-<span class="number">2</span>]+nums[i-<span class="number">1</span>]) &gt; <span class="number">26</span>:</span><br><span class="line">                        dp[i] = dp[i-<span class="number">1</span>]</span><br><span class="line">                    <span class="comment"># 当前数字和前一个数字组合或者不组合</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dp[i] = dp[i-<span class="number">2</span>] + dp[i-<span class="number">1</span>]    </span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h2 id="bm-70-兑换零钱一">BM 70 兑换零钱（一）</h2>
<p>url：<a
target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/3911a20b3f8743058214ceaa099eeb45">牛客
BM70</a></p>
<p>考察知识点：动态规划</p>
<p>先看一下不要求零钱数为整数的解法，该解法通过字典来记录子问题的解法，我觉得这道题用这种方法灵活度更高一些。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 最少货币数</span></span><br><span class="line"><span class="comment"># @param arr int整型一维数组 the array</span></span><br><span class="line"><span class="comment"># @param aim int整型 the target</span></span><br><span class="line"><span class="comment"># @return int整型</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minMoney</span>(<span class="params">self , arr: <span class="type">List</span>[<span class="built_in">int</span>], aim: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># 排序一下面额，先从大面额的开始试</span></span><br><span class="line">        arr.sort(reverse=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 零钱备忘录</span></span><br><span class="line">        dp = &#123;<span class="number">0</span>: <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 递归最少找零</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">give_change</span>(<span class="params">aim</span>):</span><br><span class="line">            <span class="keyword">if</span> aim <span class="keyword">in</span> dp:</span><br><span class="line">                <span class="keyword">return</span> dp[aim]</span><br><span class="line"></span><br><span class="line">            result = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)):</span><br><span class="line">                <span class="keyword">if</span> aim &gt;= arr[i]:</span><br><span class="line">                    pr = give_change(aim-arr[i])</span><br><span class="line">                    <span class="keyword">if</span> pr != -<span class="number">1</span>:</span><br><span class="line">                        result.append(<span class="number">1</span> + pr)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(result) == <span class="number">0</span>:</span><br><span class="line">                dp[aim] = -<span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[aim] = <span class="built_in">min</span>(result)</span><br><span class="line">                <span class="keyword">return</span> dp[aim]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> give_change(aim)</span><br></pre></td></tr></table></figure>
<p>当然，aim为整数也可以利用这个性质为aim建个动态规划的数组，更省空间一些。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 最少货币数</span></span><br><span class="line"><span class="comment"># @param arr int整型一维数组 the array</span></span><br><span class="line"><span class="comment"># @param aim int整型 the target</span></span><br><span class="line"><span class="comment"># @return int整型</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minMoney</span>(<span class="params">self , arr: <span class="type">List</span>[<span class="built_in">int</span>], aim: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        dp = [-<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(aim+<span class="number">1</span>)]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 基本案例</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(aim+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> arr:</span><br><span class="line">                <span class="comment"># 如果是面额里的零钱直接找一张就可以了</span></span><br><span class="line">                dp[i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果不是那就需要组合</span></span><br><span class="line">                <span class="comment"># 因为有找不开的情况因此开个列表记录一下找零情况</span></span><br><span class="line">                result = []</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> arr:</span><br><span class="line">                    <span class="keyword">if</span> j &lt;= i <span class="keyword">and</span> dp[i-j] != -<span class="number">1</span>:</span><br><span class="line">                        result.append(dp[i-j] + <span class="number">1</span>)</span><br><span class="line">                <span class="comment"># 取能找开情况下的最小值</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(result) &gt; <span class="number">0</span>:</span><br><span class="line">                    dp[i] = <span class="built_in">min</span>(result)</span><br><span class="line">        <span class="keyword">return</span> dp[aim]</span><br></pre></td></tr></table></figure>
<h2 id="bm-71-最长上升子序列一">BM 71 最长上升子序列（一）</h2>
<p>url：<a
target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/5164f38b67f846fb8699e9352695cd2f">牛客
BM71</a></p>
<p>考察知识点：动态规划</p>
<p>动态规划里很经典的题，思考的方式是先看看之前的数组中的上升子序列能不能拼入该元素，然后取能拼入该元素的最长上升子序列长度作为以该元素结尾的最长上升子序列长度。整个问题的答案是dp数组中的最大值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 给定数组的最长严格上升子序列的长度。</span></span><br><span class="line"><span class="comment"># @param arr int整型一维数组 给定的数组</span></span><br><span class="line"><span class="comment"># @return int整型</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">LIS</span>(<span class="params">self , arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        dp = [<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr))]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)):</span><br><span class="line">            tmp_max_length = <span class="number">1</span>  <span class="comment"># 最少是1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">                <span class="comment"># 往前看看有没有比该元素更小的元素</span></span><br><span class="line">                <span class="comment"># 有的话加入该元素可以组成一个新的更长的严格上升子序列</span></span><br><span class="line">                <span class="keyword">if</span> arr[j] &lt; arr[i] <span class="keyword">and</span> dp[j] + <span class="number">1</span> &gt; tmp_max_length:</span><br><span class="line">                        tmp_max_length = dp[j] + <span class="number">1</span></span><br><span class="line">            dp[i] = tmp_max_length</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp) <span class="keyword">if</span> <span class="built_in">len</span>(dp) &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h2 id="bm-72-连续子数组的最大和">BM 72 连续子数组的最大和</h2>
<p>url：<a
target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/459bd355da1549fa8a49e350bf3df484">牛客
BM72</a></p>
<p>考察知识点：动态规划、贪心算法</p>
<p>核心是观察出对于某个位置结尾的和最大子数组，它要么是前一个元素子数组的最大和子数组拼上自己，要么是它本身。那可以写出动态规划版本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param array int整型一维数组 </span></span><br><span class="line"><span class="comment"># @return int整型</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">FindGreatestSumOfSubArray</span>(<span class="params">self , array: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        dp = [-<span class="number">101</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(array))]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(array)):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                dp[i] = array[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 对于非第一个元素来说，</span></span><br><span class="line">                <span class="comment"># 最大值要么是前面最长的数组拼上自己</span></span><br><span class="line">                <span class="comment"># 要么是自己本身</span></span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>]+array[i], array[i])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br></pre></td></tr></table></figure>
<p>当然，也可以取缔掉整个dp数组转而只维护之前的子数组最大值和全局子数组最大值，因为我们只关心dp数组中的上一个值和最大值嘛。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param array int整型一维数组 </span></span><br><span class="line"><span class="comment"># @return int整型</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">FindGreatestSumOfSubArray</span>(<span class="params">self , array: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        last_max = array[<span class="number">0</span>]</span><br><span class="line">        max_value = array[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(array)):</span><br><span class="line">            <span class="comment"># 非最大元素要么是之前的最大值拼上自己要么是自己本身</span></span><br><span class="line">            <span class="keyword">if</span> last_max &gt; <span class="number">0</span>:</span><br><span class="line">                last_max = last_max + array[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                last_max = array[i]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 判断一下是不是全局最大</span></span><br><span class="line">            <span class="keyword">if</span> last_max &gt; max_value:</span><br><span class="line">                max_value = last_max</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max_value</span><br></pre></td></tr></table></figure>
<h2 id="bm-73-最长回文字符串">BM 73 最长回文字符串</h2>
<p>url：<a
target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/b4525d1d84934cf280439aeecc36f4af">BM
73</a></p>
<p>考察知识点：动态规划</p>
<p>先用暴力解法做一遍，关键是判断回文字符串。所谓回文字符串就是正向遍历和反向遍历相同的字符串：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param A string字符串 </span></span><br><span class="line"><span class="comment"># @return int整型</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getLongestPalindrome</span>(<span class="params">self , A: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        max_length = <span class="number">0</span></span><br><span class="line">        n = <span class="built_in">len</span>(A)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, n):</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> <span class="keyword">and</span> A[i:j+<span class="number">1</span>] == A[j: : -<span class="number">1</span>]) <span class="keyword">or</span> \</span><br><span class="line">                    (i &gt; <span class="number">0</span> <span class="keyword">and</span> A[i:j+<span class="number">1</span>] == A[j: i-<span class="number">1</span>: -<span class="number">1</span>]):</span><br><span class="line">                    <span class="comment"># 回文字符</span></span><br><span class="line">                    <span class="keyword">if</span> j - i + <span class="number">1</span> &gt; max_length:</span><br><span class="line">                        max_length = j - i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> max_length</span><br></pre></td></tr></table></figure>
<p>这里判断回文字符串实际上还需要一次循环，因此这个代码复杂度实际来到<span
class="math inline">\(O(n^3)\)</span>了，比较坏。可以使用扩散中心法来确定回文串长度，所谓扩散中心法就是把当前（或当前元素及其前一个元素）当作回文串的中心，然后向两边扩散直到不满足回文串定义。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param A string字符串 </span></span><br><span class="line"><span class="comment"># @return int整型</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getLongestPalindrome</span>(<span class="params">self , A: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        max_length = <span class="number">1</span></span><br><span class="line">        n = <span class="built_in">len</span>(A)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">helper</span>(<span class="params">left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>):</span><br><span class="line">            <span class="comment"># 扩散中心法求回文串长度</span></span><br><span class="line">            <span class="keyword">while</span> left &gt;= <span class="number">0</span> <span class="keyword">and</span> right &lt; n <span class="keyword">and</span> A[right] == A[left]:</span><br><span class="line">                left -= <span class="number">1</span></span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> right - left - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            cur = <span class="built_in">max</span>(helper(i, i), helper(i-<span class="number">1</span>, i))</span><br><span class="line">            <span class="keyword">if</span> cur &gt; max_length:</span><br><span class="line">                max_length = cur</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max_length</span><br></pre></td></tr></table></figure>
<p>动态规划的写法稍微有点点麻烦，不过核心是<span
class="math inline">\(dp[i][j]\)</span>代表什么，如果<span
class="math inline">\(dp[i][j]\)</span>代表以i开头，以j结尾的字符子串是否为回文字符串的话就会豁然开朗。当A[i]=A[j]时，就有可能产生回文串。如果<span
class="math inline">\(j-i+1 =
2\)</span>也即字符串长度等于2时，那么肯定是回文串，或者如果<span
class="math inline">\(dp[i+1][j-1]\)</span>是回文串的话那<span
class="math inline">\(dp[i][j]\)</span>也为回文串。有了这个想法，可以编写代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param A string字符串 </span></span><br><span class="line"><span class="comment"># @return int整型</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getLongestPalindrome</span>(<span class="params">self , A: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        max_length = <span class="number">1</span></span><br><span class="line">        n = <span class="built_in">len</span>(A)</span><br><span class="line">        dp = [[<span class="literal">False</span>]*n <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 基础用例</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            dp[i][i] = <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 注意dp[i][j]代表字符串s的i..j位置是否为回文串</span></span><br><span class="line">        <span class="comment"># 而dp[i][j]需要dp[i+1][j-1]的信息</span></span><br><span class="line">        <span class="comment"># 因此i需要逆序遍历，j需要顺序遍历</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> A[i] == A[j]:</span><br><span class="line">                    <span class="keyword">if</span> j -i + <span class="number">1</span> == <span class="number">2</span> <span class="keyword">or</span> dp[i+<span class="number">1</span>][j-<span class="number">1</span>]:</span><br><span class="line">                        <span class="comment"># 长度为2或者里面的子串是回文串则当前串是回文串</span></span><br><span class="line">                        dp[i][j] = <span class="literal">True</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 更新最大长度</span></span><br><span class="line">                <span class="keyword">if</span> dp[i][j] <span class="keyword">and</span> j - i + <span class="number">1</span> &gt; max_length:</span><br><span class="line">                    max_length = j -i + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max_length</span><br></pre></td></tr></table></figure>
<h2 id="bm-74-数字字符串转化成ip地址">BM 74 数字字符串转化成IP地址</h2>
<p>url：<a
target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/ce73540d47374dbe85b3125f57727e1e">牛客
BM74</a></p>
<p>考察知识点：回溯法</p>
<p>这道题完全不知道怎么用动态规划做，先写了一版用回溯法做的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param s string字符串 </span></span><br><span class="line"><span class="comment"># @return string字符串一维数组</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">restoreIpAddresses</span>(<span class="params">self , s: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        result = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">v, s</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(v) == <span class="number">4</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span>:</span><br><span class="line">                    <span class="comment"># 这里是合格叶节点</span></span><br><span class="line">                    result.append(<span class="string">&quot;.&quot;</span>.join(v))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 深度优先搜索</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">                    <span class="comment"># 判断字符串够不够长</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">len</span>(s) &lt; i+<span class="number">1</span>:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    </span><br><span class="line">                    region = s[:i+<span class="number">1</span>]</span><br><span class="line">                    next_s = s[i+<span class="number">1</span>: ]</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 判断是否为合格的域</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">len</span>(region) &gt; <span class="number">1</span> <span class="keyword">and</span> region[<span class="number">0</span>] == <span class="string">&quot;0&quot;</span>:</span><br><span class="line">                        <span class="comment"># 以0开头的数字必须只有一位</span></span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">elif</span> <span class="built_in">int</span>(region) &gt; <span class="number">255</span>:</span><br><span class="line">                        <span class="comment"># 大于255的也不是合格数组</span></span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment"># 进入下一层</span></span><br><span class="line">                    v.append(region)</span><br><span class="line">                    dfs(v, next_s)</span><br><span class="line">            <span class="comment"># 回溯</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(v) &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">del</span> v[-<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        dfs([], s)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p>原来不是用动态规划解的，那没事了。补充一种3分割点的循环方法吧。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param s string字符串 </span></span><br><span class="line"><span class="comment"># @return string字符串一维数组</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">restoreIpAddresses</span>(<span class="params">self , s: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        result = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, i+<span class="number">4</span>):</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(j+<span class="number">1</span>, j+<span class="number">4</span>):</span><br><span class="line">                    <span class="comment"># 观察k后面是否越界</span></span><br><span class="line">                    <span class="keyword">if</span> k &gt; <span class="built_in">len</span>(s)-<span class="number">1</span>:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment"># 没越界的话划分各个region</span></span><br><span class="line">                    regions = [s[:i], s[i: j], s[j: k], s[k:]]</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment"># 检查各个region是否合法</span></span><br><span class="line">                    vaild = <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">for</span> region <span class="keyword">in</span> regions:</span><br><span class="line">                        <span class="keyword">if</span> <span class="built_in">len</span>(region) &gt; <span class="number">3</span>:</span><br><span class="line">                            vaild = <span class="literal">False</span></span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                        <span class="keyword">elif</span> <span class="built_in">len</span>(region) &gt; <span class="number">1</span> <span class="keyword">and</span> region[<span class="number">0</span>] == <span class="string">&quot;0&quot;</span>:</span><br><span class="line">                            vaild = <span class="literal">False</span></span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                        <span class="keyword">elif</span> <span class="built_in">int</span>(region) &gt; <span class="number">256</span>:</span><br><span class="line">                            vaild = <span class="literal">False</span></span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment"># 如果每个region都合法就是正确的IP组合</span></span><br><span class="line">                    <span class="keyword">if</span> vaild:</span><br><span class="line">                        result.append(<span class="string">&quot;.&quot;</span>.join(regions))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h1 id="月23日">9月23日</h1>
<h2 id="bm-75-编辑距离一">BM 75 编辑距离（一）</h2>
<p>url：<a
target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/6a1483b5be1547b1acd7940f867be0da">牛客
BM75</a></p>
<p>考察知识点：动态规划</p>
<p>本题的关键就是明白三个编辑操作实际上起到什么作用，插入是往str1中加入一个字符，那么str2的指针后移一位，str1指针不动；删除则是删除str1的一个字符，那么str1指针后移一位，str2指针不动；替换是将str1位置指针元素替换为str2的对应元素，两个字符串指针都后移一位。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param str1 string字符串 </span></span><br><span class="line"><span class="comment"># @param str2 string字符串 </span></span><br><span class="line"><span class="comment"># @return int整型</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">editDistance</span>(<span class="params">self , str1: <span class="built_in">str</span>, str2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        n = <span class="built_in">len</span>(str1)</span><br><span class="line">        m = <span class="built_in">len</span>(str2)</span><br><span class="line">        dp = [[<span class="number">0</span>]*(m+<span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                    dp[i][j] = j</span><br><span class="line">                <span class="keyword">elif</span> j == <span class="number">0</span>:</span><br><span class="line">                    dp[i][j] = i</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 判断两个位置的字符是否相同</span></span><br><span class="line">                    <span class="keyword">if</span> str1[i-<span class="number">1</span>] == str2[j-<span class="number">1</span>]:</span><br><span class="line">                        <span class="comment"># 相同就什么也不做继续判断下一位</span></span><br><span class="line">                        dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="comment"># 反之则尝试进行编辑</span></span><br><span class="line">                        <span class="comment"># 分别对应删除、插入和替换操作</span></span><br><span class="line">                        dp[i][j] = <span class="built_in">min</span>(dp[i-<span class="number">1</span>][j] + <span class="number">1</span>, </span><br><span class="line">                                        dp[i][j-<span class="number">1</span>] + <span class="number">1</span>, </span><br><span class="line">                                        dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n][m]</span><br></pre></td></tr></table></figure>
<h1 id="月25日">9月25日</h1>
<h2 id="bm-76-正则表达式匹配">BM 76 正则表达式匹配</h2>
<p>url：<a
target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/28970c15befb4ff3a264189087b99ad4">牛客
BM76</a></p>
<p>考察知识点：正则表达式原理、动态规划</p>
<p>在《算法
（第4版）》的字符串章节有详细介绍正则表达式的原理，系统性地学习了一下可以编写如下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param str string字符串 </span></span><br><span class="line"><span class="comment"># @param pattern string字符串 </span></span><br><span class="line"><span class="comment"># @return bool布尔型</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Union</span>, <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Digraph</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;用邻接表储存有向图的数据结构&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, V: <span class="built_in">int</span></span>):</span><br><span class="line">        self.V = V</span><br><span class="line">        self.E = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 邻接表</span></span><br><span class="line">        self.adj = [<span class="built_in">set</span>() <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(V)]</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_edge</span>(<span class="params">self, v: <span class="built_in">int</span>, w: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;添加边&quot;&quot;&quot;</span></span><br><span class="line">        self.adj[v].add(w)</span><br><span class="line">        self.E += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_adj</span>(<span class="params">self, v: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取边的邻接表&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.adj[v]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DirectedDFS</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;判断有向图可达性的API&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, G: Digraph, sources: <span class="type">Union</span>[<span class="built_in">int</span>, <span class="type">List</span>[<span class="built_in">int</span>]]</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;sources可以是单个数字，代表单点。也可以是一个列表，代表多点情况下的可达性&quot;&quot;&quot;</span></span><br><span class="line">        self.marked_list = [<span class="literal">False</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(G.V)]</span><br><span class="line">        <span class="comment"># 把单点情况处理为多点</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(sources, <span class="built_in">int</span>):</span><br><span class="line">            sources = [sources]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 多点可达性DFS</span></span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> sources:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.marked_list[s]:</span><br><span class="line">                self.dfs(G, s)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">marked</span>(<span class="params">self, v: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回该点是否可达&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.marked_list[v]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">self, G: Digraph, v: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;用深度优先搜索判断可达性&quot;&quot;&quot;</span></span><br><span class="line">        self.marked_list[v] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> G.adj[v]:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.marked_list[w]:</span><br><span class="line">                self.dfs(G, w)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">match</span>(<span class="params">self , str1: <span class="built_in">str</span>, pattern: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">recognizes</span>(<span class="params">txt: <span class="built_in">str</span>, G: Digraph, re: <span class="type">List</span>[<span class="built_in">str</span>]</span>):</span><br><span class="line">            <span class="string">&quot;&quot;&quot;通过NFA判断文本txt来是否能识别&quot;&quot;&quot;</span></span><br><span class="line">            pc = <span class="built_in">set</span>()</span><br><span class="line">            dfs = DirectedDFS(G, <span class="number">0</span>)</span><br><span class="line">            M = <span class="built_in">len</span>(re)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> <span class="built_in">range</span>(G.V):</span><br><span class="line">                <span class="keyword">if</span> dfs.marked(v):</span><br><span class="line">                    pc.add(v)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(txt)):</span><br><span class="line">                <span class="comment"># 计算txt[i+1]能够到达的所有NFA状态</span></span><br><span class="line">                match_list = <span class="built_in">set</span>()</span><br><span class="line">                <span class="keyword">for</span> v <span class="keyword">in</span> pc:</span><br><span class="line">                    <span class="keyword">if</span> v &lt; M:</span><br><span class="line">                        <span class="comment"># 字符或.号就match到v+1</span></span><br><span class="line">                        <span class="keyword">if</span> re[v] == txt[i] <span class="keyword">or</span> re[v] == <span class="string">&quot;.&quot;</span>:</span><br><span class="line">                            match_list.add(v+<span class="number">1</span>)</span><br><span class="line">                </span><br><span class="line">                pc = <span class="built_in">set</span>()</span><br><span class="line">                dfs = DirectedDFS(G, match_list)</span><br><span class="line">                <span class="comment"># 计算新一轮可到达状态</span></span><br><span class="line">                <span class="keyword">for</span> v <span class="keyword">in</span> <span class="built_in">range</span>(G.V):</span><br><span class="line">                    <span class="keyword">if</span> dfs.marked(v):</span><br><span class="line">                        pc.add(v)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 判断是否到达接受状态</span></span><br><span class="line">            <span class="keyword">if</span> M <span class="keyword">in</span> pc:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">NFA</span>(<span class="params">regexp: <span class="built_in">str</span></span>):</span><br><span class="line">            <span class="string">&quot;&quot;&quot;根据给定表达式构造NFA(非确定有限自动机)&quot;&quot;&quot;</span></span><br><span class="line">            ops = []</span><br><span class="line">            re = <span class="built_in">list</span>(regexp)</span><br><span class="line">            M = <span class="built_in">len</span>(re)</span><br><span class="line">            G = Digraph(M+<span class="number">1</span>)  <span class="comment"># 最后加一个接受状态</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(M):</span><br><span class="line">                lp = i</span><br><span class="line">                <span class="keyword">if</span> re[i] == <span class="string">&quot;(&quot;</span> <span class="keyword">or</span> re[i] == <span class="string">&quot;|&quot;</span>:</span><br><span class="line">                    ops.append(i)</span><br><span class="line">                <span class="keyword">elif</span> re[i] == <span class="string">&quot;)&quot;</span>:</span><br><span class="line">                    op_i = ops.pop()</span><br><span class="line">                    <span class="keyword">if</span> re[op_i] == <span class="string">&quot;|&quot;</span>:</span><br><span class="line">                        lp = ops.pop()</span><br><span class="line">                        G.add_edge(lp, op_i+<span class="number">1</span>)</span><br><span class="line">                        G.add_edge(op_i, i)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        lp = op_i</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> i &lt; M-<span class="number">1</span> <span class="keyword">and</span> re[i+<span class="number">1</span>] == <span class="string">&quot;*&quot;</span>:  <span class="comment"># 查看下一个字符</span></span><br><span class="line">                    G.add_edge(lp, i+<span class="number">1</span>)</span><br><span class="line">                    G.add_edge(i+<span class="number">1</span>, lp)</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> re[i] == <span class="string">&quot;(&quot;</span> <span class="keyword">or</span> re[i] == <span class="string">&quot;*&quot;</span> <span class="keyword">or</span> re[i] == <span class="string">&quot;)&quot;</span>:</span><br><span class="line">                    G.add_edge(i, i+<span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> G, re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">match0</span>(<span class="params">regexp: <span class="built_in">str</span>, txt: <span class="built_in">str</span></span>):</span><br><span class="line">            <span class="string">&quot;&quot;&quot;返回字符串txt是否满足表达式regexp的结果&quot;&quot;&quot;</span></span><br><span class="line">            G, re = NFA(<span class="string">&quot;(&quot;</span> + regexp + <span class="string">&quot;)&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> recognizes(txt, G, re)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> match0(pattern, str1)</span><br></pre></td></tr></table></figure>
<p>具体而言，主要使用了非确定有限状态机(NFA)和图的多点可达性性质，如果到达接受状态就是匹配上了，反之没匹配上。</p>
<p>这个是相对完整的正则表达式实现，如果只有通配符"."和闭包"*"的话应该能简单不少。我们看看动态规划版本的实现。</p>
<p>动态规划版本的实现比较巧妙，充分利用了"."和"*"的特性。</p>
<p>如果str1和pattern最末尾都是字符而且不匹配的话，那它们一定不匹配。如果是字符或通配符而且匹配的话，那就看str1[:-1]和pattern[:-1]是否匹配即可。</p>
<p>如果pattern最末尾是"*"号，那么有两种情况，一种就是pattern上一个字符和现在str1最末尾的字符匹配，那么它可以重复至少一次或者不重复，即为其上方和左二位置取或操作。另一种就是pattern上一个字符和现在str1最末尾的字符不匹配，那么它不能重复，就只能取左二位置的值。</p>
<p>实现如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param str string字符串 </span></span><br><span class="line"><span class="comment"># @param pattern string字符串 </span></span><br><span class="line"><span class="comment"># @return bool布尔型</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">match</span>(<span class="params">self , str1: <span class="built_in">str</span>, pattern: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        n = <span class="built_in">len</span>(str1)</span><br><span class="line">        m = <span class="built_in">len</span>(pattern)</span><br><span class="line">        dp = [[<span class="literal">False</span>]*(m+<span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始值</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 初始化第0列，即pattern为空字符串不为空的情况，初始化的时候本来就是False，初始化已经做到了所以不额外写了</span></span><br><span class="line">        <span class="comment"># 初始化第0行</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 空字符串和pattern的匹配情况</span></span><br><span class="line">            <span class="keyword">if</span> pattern[j-<span class="number">1</span>] == <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j-<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 动态规划递推</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> pattern[j-<span class="number">1</span>] == <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                    <span class="comment"># 如果是*而且前一个字符与当前字符相同</span></span><br><span class="line">                    <span class="comment"># 观察其上方和左二的值</span></span><br><span class="line">                    <span class="keyword">if</span> pattern[j-<span class="number">2</span>] == <span class="string">&quot;.&quot;</span> <span class="keyword">or</span> pattern[j-<span class="number">2</span>] == str1[i-<span class="number">1</span>]:</span><br><span class="line">                        dp[i][j] = dp[i-<span class="number">1</span>][j] <span class="keyword">or</span> dp[i][j-<span class="number">2</span>]</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="comment"># 反之则只能令该字符重复0次</span></span><br><span class="line">                        dp[i][j] = dp[i][j-<span class="number">2</span>]</span><br><span class="line">                <span class="keyword">elif</span> pattern[j-<span class="number">1</span>] == str1[i-<span class="number">1</span>] <span class="keyword">or</span> pattern[j-<span class="number">1</span>] == <span class="string">&quot;.&quot;</span>:</span><br><span class="line">                    <span class="comment"># 如果是字符/通配符而且二者匹配时</span></span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 不是通配符而且二者不匹配</span></span><br><span class="line">                    dp[i][j] = <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n][m]</span><br></pre></td></tr></table></figure>
<h2 id="bm-77-最长的括号子串">BM 77 最长的括号子串</h2>
<p>url：<a
target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/45fd68024a4c4e97a8d6c45fc61dc6ad">牛客
BM77</a></p>
<p>考察知识点：动态规划</p>
<p>这题还挺难的，我写了一版好难到<span
class="math inline">\(O(n)\)</span>复杂度，总是要<span
class="math inline">\(O(n^2)\)</span>复杂度。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param s string字符串 </span></span><br><span class="line"><span class="comment"># @return int整型</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestValidParentheses</span>(<span class="params">self , s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="comment"># dp[i]以0..i-1的最长的格式正确子串</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">get_max</span>(<span class="params">end: <span class="built_in">int</span></span>):</span><br><span class="line">            <span class="comment"># 通过栈来检测该字符串是否合法</span></span><br><span class="line">            stack = []</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 倒序检查</span></span><br><span class="line">            j = end</span><br><span class="line">            max_ = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> s[j] == <span class="string">&quot;)&quot;</span>:</span><br><span class="line">                    stack.append(<span class="string">&quot;)&quot;</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">len</span>(stack) == <span class="number">0</span>:</span><br><span class="line">                        <span class="comment"># 如果不匹配那就直接返回</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        stack.pop()</span><br><span class="line">                        <span class="keyword">if</span> <span class="built_in">len</span>(stack) == <span class="number">0</span>:</span><br><span class="line">                            max_ = end - j + <span class="number">1</span> + dp[j]</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> max_</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(n)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> s[i-<span class="number">1</span>] == <span class="string">&quot;)&quot;</span>:</span><br><span class="line">                dp[i] = get_max(i-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br></pre></td></tr></table></figure>
<p>大致的想法就是倒序检查，如果遇到能闭合的那就说明这段可以不用考虑了，以该元素结尾的最长的子串就是这段的长度加上它后面最长的子串。</p>
<p>这个方法是<span
class="math inline">\(O(n^2)\)</span>复杂度的，并不能通过所有的测试用例。真正的解法在这上面要做一些改动。就是前面的虽然没有闭合，但是已经知道以某位置元素结尾的最长子串长度了，那直接跳过就能大大优化速度。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param s string字符串 </span></span><br><span class="line"><span class="comment"># @return int整型</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestValidParentheses</span>(<span class="params">self , s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="comment"># dp[i]以0..i-1的最长的格式正确子串</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">get_max</span>(<span class="params">end: <span class="built_in">int</span></span>):</span><br><span class="line">            <span class="comment"># 通过栈来检测该字符串是否合法</span></span><br><span class="line">            stack = []</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 倒序检查</span></span><br><span class="line">            j = end</span><br><span class="line">            <span class="keyword">if</span> j &lt; <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">elif</span> s[j] == <span class="string">&quot;(&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">elif</span> s[j] == <span class="string">&quot;)&quot;</span> <span class="keyword">and</span> s[j-<span class="number">1</span>] == <span class="string">&quot;(&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> dp[j-<span class="number">1</span>] + <span class="number">2</span></span><br><span class="line">            <span class="keyword">elif</span> s[j-<span class="number">1</span>] == <span class="string">&quot;)&quot;</span> <span class="keyword">and</span> j - dp[j] - <span class="number">1</span> &gt;= <span class="number">0</span> <span class="keyword">and</span> s[j-dp[j]-<span class="number">1</span>] == <span class="string">&quot;(&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> dp[j-dp[j]-<span class="number">1</span>] + dp[j] + <span class="number">2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            dp[i] = get_max(i-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br></pre></td></tr></table></figure>
<p>上面这样可以通过所有的测试用例了，然后每次也不涉及到变量j的迭代，因此复杂度被控制在<span
class="math inline">\(O(n)\)</span>了。但是显然如果考虑到以j结尾的最长子串后，实际上不需要这个栈来检验了。跳过已经匹配了的子串后所有的匹配都是朴实的"()"匹配。</p>
<p>因此，我们可以重新写一下这个动态规划版本，不需要这些栈来辅助检查了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param s string字符串 </span></span><br><span class="line"><span class="comment"># @return int整型</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestValidParentheses</span>(<span class="params">self , s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="comment"># dp[i]以0..i-1的最长的格式正确子串</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 直接从第二个数开始检查</span></span><br><span class="line">            <span class="keyword">if</span> s[i-<span class="number">1</span>] == <span class="string">&quot;)&quot;</span>:</span><br><span class="line">                <span class="keyword">if</span> s[i-<span class="number">2</span>] == <span class="string">&quot;(&quot;</span>:</span><br><span class="line">                    <span class="comment"># 左右匹配那是最好的，直接跳到后面的子串长度问题</span></span><br><span class="line">                    dp[i] = dp[i-<span class="number">2</span>] + <span class="number">2</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 如果不匹配得看跳过已经匹配的子串后是否匹配</span></span><br><span class="line">                    <span class="keyword">if</span> i - dp[i-<span class="number">1</span>] - <span class="number">2</span> &gt;= <span class="number">0</span> <span class="keyword">and</span> s[i-dp[i-<span class="number">1</span>]-<span class="number">2</span>] == <span class="string">&quot;(&quot;</span>:</span><br><span class="line">                        dp[i] = dp[i-<span class="number">1</span>] + dp[i-dp[i-<span class="number">1</span>]-<span class="number">2</span>] + <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br></pre></td></tr></table></figure>
<p>有点烦的就是注意为了避免<span
class="math inline">\(i==2\)</span>时的边界检查，我们将dp数组特地申请长了一位。然后这样会导致字符串是从<span
class="math inline">\(i-1\)</span>位开始的，因此在"如果不匹配得看跳过已经匹配的子串后是否匹配"那里实际上是在算<span
class="math inline">\(i-1 - dp[i-1] -1\)</span>的下标。因为<span
class="math inline">\(i-1\)</span>是当前位置，<span
class="math inline">\(dp[i-1]\)</span>是当前位置前一个字符组成的最长子串长度，也即要跳过的字符长度，然后跳过之后再往前一位才是与当前位置匹配的括号位置，因此是<span
class="math inline">\(i-dp[i-1]-2\)</span>。</p>
<p>还可以利用左括号匹配的坐标来做文章，以前都是直接把左括号弹进去的，啥额外信息也没有，太亏了。如果知道左括号的坐标的话，那很容易想到对于匹配的右括号可以根据坐标计算出符合规则的字串长度。这里有个不容易想到的就是如果左括号不够导致匹配失败了该怎么办，左括号不够匹配失败了那之后也一定会匹配失败，正确的方式是在发现了之后丢弃前面的子串，即把开始值重置为当前位置。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param s string字符串 </span></span><br><span class="line"><span class="comment"># @return int整型</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestValidParentheses</span>(<span class="params">self , s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        start = -<span class="number">1</span></span><br><span class="line">        stack = []</span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">&quot;(&quot;</span>:</span><br><span class="line">                stack.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(stack) == <span class="number">0</span>:</span><br><span class="line">                    <span class="comment"># 说明左括号不够用，已经不合法了</span></span><br><span class="line">                    <span class="comment"># 只能在这之前匹配</span></span><br><span class="line">                    start = i</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    stack.pop()</span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">len</span>(stack) == <span class="number">0</span>:</span><br><span class="line">                        <span class="comment"># 如果是空的那就说明到达了开始位置</span></span><br><span class="line">                        res = <span class="built_in">max</span>(res, i - start)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="comment"># 如果非空只能匹配到上一个左括号的位置</span></span><br><span class="line">                        res = <span class="built_in">max</span>(res, i-stack[-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h2 id="bm-78-打家劫舍一">BM 78 打家劫舍（一）</h2>
<p>url：<a
target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/c5fbf7325fbd4c0ea3d0c3ea6bc6cc79">牛客
BM78</a></p>
<p>考察知识点：动态规划</p>
<p>我们可以从是否要打劫第i家开始考虑，如果要打劫第i家，必须放弃第i-1家的打劫，只能获取从开始到第i-2家的收益。反之，如果不打劫第i家，那么可以获取从开始到第i-1家的收益。那么走到第i家的最大收益就是前面两种情况的最大值，也即：
<span class="math display">\[
dp[i] = max(dp[i-1], dp[i-2]+nums[i])
\]</span>
那为了避免处理只有一家或者只有两家之类的边界条件，我们可以人为在nums最开头插入两户虚拟人家，价值都是0，然后直接从第三户开始考虑：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param nums int整型一维数组 </span></span><br><span class="line"><span class="comment"># @return int整型</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rob</span>(<span class="params">self , nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># 创建两个虚拟的0节点，兼容不同数量</span></span><br><span class="line">        nums.insert(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        nums.insert(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n):</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>], dp[i-<span class="number">2</span>]+nums[i])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>这样应该是本问题的最优解了。但是如果不插入虚拟节点呢，也即如果没有这两户虚拟人家dp数组该怎么初始化呢？这里有个隐藏的bug，就是如果认为在第2家的时候不打劫第2家，那就亏了！因此会把dp的前两个数组初始化为：
<span class="math display">\[
dp[0]=nums[0], dp[1]=nums[1]
\]</span> 但这实际上埋下祸根，我们考虑一下这样的nums: <span
class="math inline">\([5, 1, 3,
7]\)</span>。按照之前的初始化dp数组为：<span class="math inline">\([5,
1, 8,
8]\)</span>，所以最后最大结果是8。但打劫第1家和第4家的话结果是12，与结果不同。问题出在哪了呢？走到第2家时非要打劫第2家吗，我们也可以打劫第1家，只要第1家比第2家值钱，那么就应该打劫第1家而放弃第2家。弄清楚这个问题之后可以知道初始化应该是：
<span class="math display">\[
dp[0]=nums[0],dp[1]=max(nums[0], nums[1])
\]</span> 实现如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param nums int整型一维数组 </span></span><br><span class="line"><span class="comment"># @return int整型</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rob</span>(<span class="params">self , nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># 创建两个虚拟的0节点，兼容不同数量</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">elif</span> i == <span class="number">1</span>:</span><br><span class="line">                dp[<span class="number">1</span>] = <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>], dp[i-<span class="number">2</span>]+nums[i])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h2 id="bm-79-打家劫舍二">BM 79 打家劫舍（二）</h2>
<p>url：<a
target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/a5c127769dd74a63ada7bff37d9c5815">牛客
BM79</a></p>
<p>考察知识点：动态规划</p>
<p>相比一把场景换成圆形的了。圆形的同时偷第一个和偷最后一个就会冲突。如果分成两个子问题考虑就可以剪断这个环，一是我从第一家走到第n-1家，最后一家我不看了；二是我从第2家走到最后一家，第一家我不看了。然后取这两个子问题的最大值就是整个问题的最大值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param nums int整型一维数组 </span></span><br><span class="line"><span class="comment"># @return int整型</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rob</span>(<span class="params">self , nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 分成两部分考虑，一是不偷第一家，考虑1..n的最大值</span></span><br><span class="line">        <span class="comment"># 二是不偷最后一家，考虑0..n-1的最大值</span></span><br><span class="line">        dp1 = [<span class="number">0</span>] * n</span><br><span class="line">        dp2 = [<span class="number">0</span>] * n</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                dp2[i] = nums[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">elif</span> i == <span class="number">1</span>:</span><br><span class="line">                dp2[i] = <span class="built_in">max</span>(dp2[<span class="number">0</span>], nums[i])</span><br><span class="line">                dp1[i] = nums[i]</span><br><span class="line">            <span class="keyword">elif</span> i == n-<span class="number">1</span>:</span><br><span class="line">                dp2[i] = dp2[i-<span class="number">1</span>]</span><br><span class="line">                dp1[i] = <span class="built_in">max</span>(dp1[i-<span class="number">1</span>], dp1[i-<span class="number">2</span>]+nums[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp2[i] = <span class="built_in">max</span>(dp2[i-<span class="number">1</span>], dp2[i-<span class="number">2</span>]+nums[i])</span><br><span class="line">                dp1[i] = <span class="built_in">max</span>(dp1[i-<span class="number">1</span>], dp1[i-<span class="number">2</span>]+nums[i])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp1[-<span class="number">1</span>], dp2[-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<h1 id="月26日">9月26日</h1>
<h2 id="bm-80-买卖股票的最好时机一">BM 80 买卖股票的最好时机（一）</h2>
<p>url：<a
target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/64b4262d4e6d4f6181cd45446a5821ec">牛客
BM80</a></p>
<p>考察知识点：动态规划、贪心算法</p>
<p>第一眼看上去似乎可以先求前后一天利润的diff数组，买进卖出一次也可以看作是买进那天买入，然后每天执行买入卖出操作直到真正卖出那天。这样问题就转化为了求这个diff数组的最大和子数组了，这个问题我们在<a
target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/459bd355da1549fa8a49e350bf3df484">BM
72 连续子数组的最大和</a>中解决过。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param prices int整型一维数组 </span></span><br><span class="line"><span class="comment"># @return int整型</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self , prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        n = <span class="built_in">len</span>(prices)</span><br><span class="line">        diff = [<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            diff.append(prices[i] - prices[i-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 转为求该数组的最大和子数组</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>]+diff[i], diff[i])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br></pre></td></tr></table></figure>
<p>也可以换一种思路，我们要求的就是最大卖出价和最小买入价的差值，限制就是这个卖出操作不能先于买入操作发生。那我们可以使用两个数组buy和sell，其中buy数组记录前i天的最低买入价，sell数组记录从第i天到最后一天的最高卖出价。然后两个数组做差取最大值即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param prices int整型一维数组 </span></span><br><span class="line"><span class="comment"># @return int整型</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self , prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        n = <span class="built_in">len</span>(prices)</span><br><span class="line">        buy = [<span class="number">0</span>]*n</span><br><span class="line">        sell = [<span class="number">0</span>]*n</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 顺序求最低买入价</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                buy[<span class="number">0</span>] = prices[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                buy[i] = <span class="built_in">min</span>(prices[i], buy[i-<span class="number">1</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 倒序求最高卖出价</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> j == n - <span class="number">1</span>:</span><br><span class="line">                sell[j] = prices[j]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                sell[j] = <span class="built_in">max</span>(prices[j], sell[j+<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        _<span class="built_in">max</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> sell[i] - buy[i] &gt; _<span class="built_in">max</span>:</span><br><span class="line">                _<span class="built_in">max</span> = sell[i] - buy[i]</span><br><span class="line">        <span class="keyword">return</span> _<span class="built_in">max</span></span><br></pre></td></tr></table></figure>
<p>但是怎么用O(1)的空间复杂度完成这件事呢，根本想不到。</p>
<p>看了题解之后发现一种更清晰的dp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param prices int整型一维数组 </span></span><br><span class="line"><span class="comment"># @return int整型</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self , prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        n = <span class="built_in">len</span>(prices)</span><br><span class="line">        dp = [[<span class="number">0</span>]*<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始值</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 进行操作</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            <span class="comment"># 该天或者之前卖出</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">            <span class="comment"># 该天或者之前买入</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">1</span>], -prices[i])</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 返回最后不持股的状态</span></span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>然后也知道了用O(1)复杂度的方法，就是实际在历史最高卖出价是不需要维护的，因为我们可以记录下之前的最低买入价，然后尝试每天卖出，碰到更大的收益就记下来，最后返回最大收益。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param prices int整型一维数组 </span></span><br><span class="line"><span class="comment"># @return int整型</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self , prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        n = <span class="built_in">len</span>(prices)</span><br><span class="line">        _<span class="built_in">max</span> = <span class="number">0</span></span><br><span class="line">        best_buy_price = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="comment"># 先更新最优买入价</span></span><br><span class="line">            <span class="keyword">if</span> best_buy_price &gt; prices[i]:</span><br><span class="line">                best_buy_price = prices[i]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 查看该天卖出收益是否大于最高收益</span></span><br><span class="line">            <span class="keyword">if</span> prices[i] - best_buy_price &gt; _<span class="built_in">max</span>:</span><br><span class="line">                _<span class="built_in">max</span> = prices[i] - best_buy_price</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> _<span class="built_in">max</span></span><br></pre></td></tr></table></figure>
<h2 id="bm-81-买卖股票的最好时机二">BM 81 买卖股票的最好时机（二）</h2>
<p>url：<a
target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/9e5e3c2603064829b0a0bbfca10594e9">牛客
BM81</a></p>
<p>考察知识点：动态规划、贪心算法</p>
<p>接着BM80的想法，唯一的区别就是可以卖了再买，所以买入的时候考虑一下之前的卖出后剩下的余额即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 计算最大收益</span></span><br><span class="line"><span class="comment"># @param prices int整型一维数组 股票每一天的价格</span></span><br><span class="line"><span class="comment"># @return int整型</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self , prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        n = <span class="built_in">len</span>(prices)</span><br><span class="line">        dp = [[<span class="number">0</span>]*<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始值</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            <span class="comment"># 卖出股票</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">            <span class="comment"># 买入股票，这里和（一）有区别就是可以多次买入</span></span><br><span class="line">            <span class="comment"># 因此要考虑上次卖出后的余值</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">1</span>], dp[i-<span class="number">1</span>][<span class="number">0</span>] - prices[i])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>之前diff数组的思想也可以用上，如果允许多次买入卖出的话那也不需要连续子数组了，直接子序列的最大和即可。那啥时候子序列和最大，把数组里面的正数全算上就最大了啊。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 计算最大收益</span></span><br><span class="line"><span class="comment"># @param prices int整型一维数组 股票每一天的价格</span></span><br><span class="line"><span class="comment"># @return int整型</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self , prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        n = <span class="built_in">len</span>(prices)</span><br><span class="line">        diff = [<span class="number">0</span>]*n</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            diff[i] = prices[i] - prices[i-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 可以考虑最大和子序列，这里允许多次买卖所以不需要连续了</span></span><br><span class="line">        <span class="comment"># 实际上就是把diff为正的全加一遍</span></span><br><span class="line">        _<span class="built_in">max</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> diff[i] &gt; <span class="number">0</span>:</span><br><span class="line">                _<span class="built_in">max</span> += diff[i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> _<span class="built_in">max</span></span><br></pre></td></tr></table></figure>
<p>这时候空间复杂度O(1)的解法也呼之欲出了，如果每次我们都直接算diff[i]然后直接判断要不要进行买卖操作即可O(1)空间复杂度完成问题。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 计算最大收益</span></span><br><span class="line"><span class="comment"># @param prices int整型一维数组 股票每一天的价格</span></span><br><span class="line"><span class="comment"># @return int整型</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self , prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        n = <span class="built_in">len</span>(prices)</span><br><span class="line">        _<span class="built_in">max</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            diff = prices[i] - prices[i-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> diff &gt; <span class="number">0</span>:</span><br><span class="line">                _<span class="built_in">max</span> += diff</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> _<span class="built_in">max</span></span><br></pre></td></tr></table></figure>
<h2 id="bm-82买卖股票的最好时机三">BM 82买卖股票的最好时机（三）</h2>
<p>url：<a
target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/4892d3ff304a4880b7a89ba01f48daf9">牛客
BM82</a></p>
<p>考察知识点：动态规划</p>
<p>在（二）的基础上又加了个次数约束，我们也在（二）的dp基础上加了几个新的框用于考虑不同情况，感觉写得不优雅，但是能解决问题。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 两次交易所能获得的最大收益</span></span><br><span class="line"><span class="comment"># @param prices int整型一维数组 股票每一天的价格</span></span><br><span class="line"><span class="comment"># @return int整型</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self , prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        n = <span class="built_in">len</span>(prices)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># dp[][0]代表不持有股票的初始状态</span></span><br><span class="line">        <span class="comment"># dp[][1]代表第一次持有股票</span></span><br><span class="line">        <span class="comment"># dp[][2]代表第一次持有股票后卖出</span></span><br><span class="line">        <span class="comment"># dp[][3]代表第二次持有股票</span></span><br><span class="line">        <span class="comment"># dp[][4]代表第二次持有股票后卖出</span></span><br><span class="line">        dp = [[<span class="number">0</span>]*<span class="number">5</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始值</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># 不可到达的值要置为负无穷</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>], dp[<span class="number">0</span>][<span class="number">3</span>], dp[<span class="number">0</span>][<span class="number">4</span>] = -<span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>), -<span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>), -<span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">1</span>], -prices[i])</span><br><span class="line">            dp[i][<span class="number">2</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">2</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">            dp[i][<span class="number">3</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">3</span>], dp[i-<span class="number">1</span>][<span class="number">2</span>] - prices[i])</span><br><span class="line">            dp[i][<span class="number">4</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">4</span>], dp[i-<span class="number">1</span>][<span class="number">3</span>] + prices[i])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[-<span class="number">1</span>][<span class="number">0</span>], dp[-<span class="number">1</span>][<span class="number">2</span>], dp[-<span class="number">1</span>][<span class="number">4</span>])</span><br></pre></td></tr></table></figure>
<p>看了题解，本来以为有啥贪心的方法能达到<span
class="math inline">\(O(1)\)</span>复杂度，结果并不是靠贪心算法来搞的，而是就在原动态规划的基础上就能做得到。因为最后的结果只看最后一行的几个位置，而且迭代的时候也只需要上一行的数据就能迭代，因此可以只用两行dp数组实现。这个想法确实很有启发意义，如果对于任意下一行只依赖上一行而且结果在最后一行的动态规划算法，都可以通过两行dp数组代替那个大的dp矩阵（这样的叫法也许比较合适）来达到缩减空间复杂度的目的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 两次交易所能获得的最大收益</span></span><br><span class="line"><span class="comment"># @param prices int整型一维数组 股票每一天的价格</span></span><br><span class="line"><span class="comment"># @return int整型</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self , prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        n = <span class="built_in">len</span>(prices)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># dp[0]代表不持有股票的初始状态</span></span><br><span class="line">        <span class="comment"># dp[1]代表第一次持有股票</span></span><br><span class="line">        <span class="comment"># dp[2]代表第一次持有股票后卖出</span></span><br><span class="line">        <span class="comment"># dp[3]代表第二次持有股票</span></span><br><span class="line">        <span class="comment"># dp[4]代表第二次持有股票后卖出</span></span><br><span class="line">        dp = [<span class="number">0</span>, -prices[<span class="number">0</span>], -<span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>), -<span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>), -<span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            <span class="comment"># 这里每次只用了dp数组的上一行，因此可以两行dp交替达到O(1)复杂度</span></span><br><span class="line">            dp_i = [<span class="number">0</span>]*<span class="number">5</span></span><br><span class="line">            dp_i[<span class="number">1</span>] = <span class="built_in">max</span>(dp[<span class="number">1</span>], -prices[i])</span><br><span class="line">            dp_i[<span class="number">2</span>] = <span class="built_in">max</span>(dp[<span class="number">2</span>], dp[<span class="number">1</span>] + prices[i])</span><br><span class="line">            dp_i[<span class="number">3</span>] = <span class="built_in">max</span>(dp[<span class="number">3</span>], dp[<span class="number">2</span>] - prices[i])</span><br><span class="line">            dp_i[<span class="number">4</span>] = <span class="built_in">max</span>(dp[<span class="number">4</span>], dp[<span class="number">3</span>] + prices[i])</span><br><span class="line">            dp = dp_i</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[<span class="number">0</span>], dp[<span class="number">2</span>], dp[<span class="number">4</span>])</span><br></pre></td></tr></table></figure>
<h2 id="bm-83-字符串变形">BM 83 字符串变形</h2>
<p>url：<a
target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/c3120c1c1bc44ad986259c0cf0f0b80e">牛客
BM83</a></p>
<p>考察知识点：字符串</p>
<p>感觉用Python的API可以很容易实现，但是如果不调Python的API真的会很难受！</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param s string字符串 </span></span><br><span class="line"><span class="comment"># @param n int整型 </span></span><br><span class="line"><span class="comment"># @return string字符串</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">trans</span>(<span class="params">self , s: <span class="built_in">str</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        s_list = s.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">        s_list.reverse()</span><br><span class="line">        s = <span class="built_in">list</span>(<span class="string">&quot; &quot;</span>.join(s_list))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">ord</span>(s[i]) &gt;= <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>) <span class="keyword">and</span> <span class="built_in">ord</span>(s[i]) &lt;= <span class="built_in">ord</span>(<span class="string">&#x27;z&#x27;</span>):</span><br><span class="line">                s[i] = <span class="built_in">chr</span>(<span class="built_in">ord</span>(s[i]) - <span class="number">32</span>)</span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">ord</span>(s[i]) &gt;= <span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>) <span class="keyword">and</span> <span class="built_in">ord</span>(s[i]) &lt;= <span class="built_in">ord</span>(<span class="string">&#x27;Z&#x27;</span>):</span><br><span class="line">                s[i] = <span class="built_in">chr</span>(<span class="built_in">ord</span>(s[i]) + <span class="number">32</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(s)</span><br></pre></td></tr></table></figure>
<p>不用空格分割手动翻转了一下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param s string字符串 </span></span><br><span class="line"><span class="comment"># @param n int整型 </span></span><br><span class="line"><span class="comment"># @return string字符串</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">trans</span>(<span class="params">self , s: <span class="built_in">str</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 改变大小写</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> s[i] &gt;= <span class="string">&#x27;a&#x27;</span> <span class="keyword">and</span> s[i] &lt;= <span class="string">&#x27;z&#x27;</span>:</span><br><span class="line">                res.append(<span class="built_in">chr</span>(<span class="built_in">ord</span>(s[i]) - <span class="number">32</span>))</span><br><span class="line">            <span class="keyword">elif</span> s[i] &gt;= <span class="string">&#x27;A&#x27;</span> <span class="keyword">and</span> s[i] &lt;= <span class="string">&#x27;Z&#x27;</span>:</span><br><span class="line">                res.append(<span class="built_in">chr</span>(<span class="built_in">ord</span>(s[i]) + <span class="number">32</span>))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(s[i])</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 改变顺序</span></span><br><span class="line">        res.reverse()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将单词内部的顺序翻转回来</span></span><br><span class="line">        i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; n:</span><br><span class="line">            j = i</span><br><span class="line">            <span class="keyword">while</span> j &lt; n <span class="keyword">and</span> res[j] != <span class="string">&quot; &quot;</span>:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            temp_i, temp_j = i, j-<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> temp_i &lt; temp_j:</span><br><span class="line">                res[temp_i], res[temp_j] = res[temp_j], res[temp_i]</span><br><span class="line">                temp_i += <span class="number">1</span></span><br><span class="line">                temp_j -= <span class="number">1</span></span><br><span class="line">            i = j + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(res)</span><br></pre></td></tr></table></figure>
<h2 id="bm-84-最长公共前缀">BM 84 最长公共前缀</h2>
<p>url：<a
target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/28eb3175488f4434a4a6207f6f484f47">BM
84</a></p>
<p>考察知识点：字符串操作</p>
<p>好像没啥的，在<span
class="math inline">\(O(n*len)\)</span>复杂度下直接遍历就好了。甚至我觉得找最短字符串都有点浪费时间，不对的它自然就失败了。但是如果不先查找最短字符串的话每次还得判断下标是否越界，感觉多次调用len方法早就把找最短字符串偷的懒还回去了，因此感觉还是先找最短字符串比较好，省去内层循环判断越界。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param strs string字符串一维数组 </span></span><br><span class="line"><span class="comment"># @return string字符串</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestCommonPrefix</span>(<span class="params">self , strs: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        n = <span class="built_in">len</span>(strs)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 先查找最短的字符串</span></span><br><span class="line">        min_i = <span class="number">0</span></span><br><span class="line">        min_length = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, s <span class="keyword">in</span> <span class="built_in">enumerate</span>(strs):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(s) &lt; min_length:</span><br><span class="line">                min_length = <span class="built_in">len</span>(s)</span><br><span class="line">                min_i = i</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 用最短字符串的每个字符逐个匹配</span></span><br><span class="line">        target = strs[min_i]</span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> j &lt; min_length:</span><br><span class="line">            c = target[j]</span><br><span class="line">            valid = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">                <span class="keyword">if</span> s[j] != c:</span><br><span class="line">                    valid = <span class="literal">False</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> valid:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 注意这里第j位是未通过验证或者等于字符串长度的</span></span><br><span class="line">        <span class="comment"># 配合Python的左闭右开字符串切片是刚好的</span></span><br><span class="line">        <span class="keyword">return</span> target[:j]</span><br></pre></td></tr></table></figure>
<h2 id="bm-85-验证ip地址">BM 85 验证IP地址</h2>
<p>url：<a
target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/55fb3c68d08d46119f76ae2df7566880">牛客
BM85</a></p>
<p>考察知识点：字符串操作</p>
<p>没啥好说的，按照题目要求验证即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 验证IP地址</span></span><br><span class="line"><span class="comment"># @param IP string字符串 一个IP地址字符串</span></span><br><span class="line"><span class="comment"># @return string字符串</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">solve</span>(<span class="params">self , IP: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># 按有没有.分成IPv4, IPv6和Neither</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;.&quot;</span> <span class="keyword">in</span> IP:</span><br><span class="line">            regions = IP.split(<span class="string">&quot;.&quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(regions) != <span class="number">4</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;Neither&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> region <span class="keyword">in</span> regions:</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(region) &gt; <span class="number">1</span> <span class="keyword">and</span> region[<span class="number">0</span>] == <span class="string">&quot;0&quot;</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;Neither&quot;</span></span><br><span class="line">                <span class="keyword">elif</span> <span class="keyword">not</span> region.isdigit() <span class="keyword">or</span> <span class="built_in">int</span>(region) &gt; <span class="number">255</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;Neither&quot;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;IPv4&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">elif</span> <span class="string">&quot;:&quot;</span> <span class="keyword">in</span> IP:</span><br><span class="line">            regions = IP.split(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(regions) != <span class="number">8</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;Neither&quot;</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> region <span class="keyword">in</span> regions:</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(region) == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;Neither&quot;</span></span><br><span class="line">                <span class="keyword">elif</span> <span class="built_in">len</span>(region) &gt;= <span class="number">2</span> <span class="keyword">and</span> region[:<span class="number">2</span>] == <span class="string">&quot;00&quot;</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;Neither&quot;</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> region:</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> (j.isdigit() <span class="keyword">or</span> j <span class="keyword">in</span> <span class="string">&quot;abcdefABCDEF&quot;</span>):</span><br><span class="line">                        <span class="keyword">return</span> <span class="string">&quot;Neither&quot;</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;IPv6&quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Neither&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="bm-86-大数加法">BM 86 大数加法</h2>
<p>url：<a
target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/11ae12e8c6fe48f883cad618c2e81475">BM
86</a></p>
<p>考察知识点：字符串操作、模拟</p>
<p>一开始没看到模拟，就直接转成数字然后相加了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 计算两个数之和</span></span><br><span class="line"><span class="comment"># @param s string字符串 表示第一个整数</span></span><br><span class="line"><span class="comment"># @param t string字符串 表示第二个整数</span></span><br><span class="line"><span class="comment"># @return string字符串</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">solve</span>(<span class="params">self , s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span>:</span><br><span class="line">            num_s = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            num_s = <span class="built_in">int</span>(s)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(t) == <span class="number">0</span>:</span><br><span class="line">            num_t = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            num_t = <span class="built_in">int</span>(t)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> num_s + num_t</span><br></pre></td></tr></table></figure>
<p>模拟从低位到高位的加减法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 计算两个数之和</span></span><br><span class="line"><span class="comment"># @param s string字符串 表示第一个整数</span></span><br><span class="line"><span class="comment"># @param t string字符串 表示第二个整数</span></span><br><span class="line"><span class="comment"># @return string字符串</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">solve</span>(<span class="params">self , s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) &lt; <span class="built_in">len</span>(t):</span><br><span class="line">            s, t = t, s</span><br><span class="line">        </span><br><span class="line">        n = <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">        m = <span class="built_in">len</span>(t) - <span class="number">1</span></span><br><span class="line">        <span class="comment"># 加法进位符</span></span><br><span class="line">        mt9 = <span class="literal">False</span></span><br><span class="line">        res = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(t)):</span><br><span class="line">            s_i = <span class="built_in">ord</span>(s[n - i]) - <span class="built_in">ord</span>(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            t_i = <span class="built_in">ord</span>(t[m - i]) - <span class="built_in">ord</span>(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">            res_i = s_i + t_i</span><br><span class="line">            <span class="comment"># 考虑进位</span></span><br><span class="line">            <span class="keyword">if</span> mt9:</span><br><span class="line">                res_i += <span class="number">1</span></span><br><span class="line">                mt9 = <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 考虑结果是否大于等于10</span></span><br><span class="line">            <span class="keyword">if</span> res_i &gt;= <span class="number">10</span>:</span><br><span class="line">                mt9 = <span class="literal">True</span></span><br><span class="line">                res_i -= <span class="number">10</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 加入结果字符串中</span></span><br><span class="line">            res = <span class="string">f&quot;<span class="subst">&#123;res_i&#125;</span><span class="subst">&#123;res&#125;</span>&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 考虑剩余位数</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(t), <span class="built_in">len</span>(s)):</span><br><span class="line">            res_j = <span class="built_in">ord</span>(s[n - j]) - <span class="built_in">ord</span>(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> mt9:</span><br><span class="line">                res_j += <span class="number">1</span></span><br><span class="line">                mt9 = <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> res_j &gt;= <span class="number">10</span>:</span><br><span class="line">                mt9 = <span class="literal">True</span></span><br><span class="line">                res_j -= <span class="number">10</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 加入结果字符串中</span></span><br><span class="line">            res = <span class="string">f&quot;<span class="subst">&#123;res_j&#125;</span><span class="subst">&#123;res&#125;</span>&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 看看最后是否有剩余进位符</span></span><br><span class="line">        <span class="keyword">if</span> mt9:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">f&quot;1<span class="subst">&#123;res&#125;</span>&quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h2 id="bm-87-合并两个有序的数组">BM 87 合并两个有序的数组</h2>
<p>url：<a
target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/89865d4375634fc484f3a24b7fe65665">牛客
BM87</a></p>
<p>考察知识点：数组</p>
<p>比较新颖的地方就是要求就地插入，即后方元素必须右移。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param A int整型一维数组 </span></span><br><span class="line"><span class="comment"># @param B int整型一维数组 </span></span><br><span class="line"><span class="comment"># @return void</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self , A, m, B, n</span>):</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">move_element</span>(<span class="params">start, end</span>):</span><br><span class="line">            <span class="comment"># 将剩下的元素向后移动一位</span></span><br><span class="line">            temp = end</span><br><span class="line">            <span class="keyword">while</span> temp &gt; start:</span><br><span class="line">                A[temp] = A[temp-<span class="number">1</span>]</span><br><span class="line">                temp -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">while</span> i &lt; m + j:    </span><br><span class="line">                <span class="keyword">if</span> A[i] &gt;= B[j]:</span><br><span class="line">                    <span class="comment"># 如果大于则位置i应该放B[j]</span></span><br><span class="line">                    <span class="comment"># 此时算上即将插入的B[j]A数组中总共有m+j个有效元素</span></span><br><span class="line">                    move_element(i, m+j)</span><br><span class="line">                    A[i] = B[j]</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 如果到后面的话直接插进去就行</span></span><br><span class="line">            A[i] = B[j]</span><br></pre></td></tr></table></figure>
<p>这里有个天才的想法，就是倒过来看！如果倒过来看A的加长部分，我们把两数组的最大元素依次往后挪，就可以轻松做到不挪动已有元素然后将数组he'bing排序到位！</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param A int整型一维数组 </span></span><br><span class="line"><span class="comment"># @param B int整型一维数组 </span></span><br><span class="line"><span class="comment"># @return void</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self , A, m, B, n</span>):</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        i, j = m-<span class="number">1</span>, n-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(m+n-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 倒序合入两数组元素</span></span><br><span class="line">            <span class="keyword">if</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> A[i] &gt; B[j]:</span><br><span class="line">                A[k] = A[i]</span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">                A[k] = B[j]</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果i和j都小于0时停止</span></span><br><span class="line">                <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<h1 id="月28日">9月28日</h1>
<h2 id="bm-88-判断是否为回文字符串">BM 88 判断是否为回文字符串</h2>
<p>url：<a
target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/e297fdd8e9f543059b0b5f05f3a7f3b2">牛客
BM88</a></p>
<p>考察知识点：双指针</p>
<p>如果是链表的话需要从前往后遍历和从后往前遍历进行比较，如果是字符串这种可以用下标迭代的就用双指针即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param str string字符串 待判断的字符串</span></span><br><span class="line"><span class="comment"># @return bool布尔型</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">judge</span>(<span class="params">self , str1: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        i, j = <span class="number">0</span>, <span class="built_in">len</span>(str1)-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            <span class="keyword">if</span> str1[i] != str1[j]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h2 id="bm-89-合并区间">BM 89 合并区间</h2>
<p>url：<a
target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/69f4e5b7ad284a478777cb2a17fb5e6a">牛客
BM89</a></p>
<p>考察知识点：双指针</p>
<p>一种方式时间复杂度是<span class="math inline">\(O(n\log
n)\)</span>，空间复杂度是<span
class="math inline">\(O(n)\)</span>，<span
class="math inline">\(n\)</span>为区间的数量。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># class Interval:</span></span><br><span class="line"><span class="comment">#     def __init__(self, a=0, b=0):</span></span><br><span class="line"><span class="comment">#         self.start = a</span></span><br><span class="line"><span class="comment">#         self.end = b</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param intervals Interval类一维数组 </span></span><br><span class="line"><span class="comment"># @return Interval类一维数组</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self , intervals: <span class="type">List</span>[Interval]</span>) -&gt; <span class="type">List</span>[Interval]:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># 先对intervals的起点排序</span></span><br><span class="line">        intervals.sort(key=<span class="keyword">lambda</span> x: x.start)</span><br><span class="line">        </span><br><span class="line">        n = <span class="built_in">len</span>(intervals)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 双指针合并</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        merge_intervals = [intervals[<span class="number">0</span>]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> intervals[i].start &lt;= merge_intervals[j].end:</span><br><span class="line">                <span class="comment"># 这里说明是可合并的</span></span><br><span class="line">                <span class="comment"># 可合并也有两种情况，一种是被上一个区间包含</span></span><br><span class="line">                <span class="comment"># 另外一种是有交集但没有完全包含</span></span><br><span class="line">                <span class="comment"># 所以这里取二者的最大值</span></span><br><span class="line">                merge_intervals[j].end = <span class="built_in">max</span>(merge_intervals[j].end, intervals[i].end)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 否则这就是一个新区间</span></span><br><span class="line">                merge_intervals.append(intervals[i])</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> merge_intervals</span><br></pre></td></tr></table></figure>
<h1 id="月2日">10月2日</h1>
<h2 id="bm-90-最小覆盖子串">BM 90 最小覆盖子串</h2>
<p>url：<a
target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/c466d480d20c4c7c9d322d12ca7955ac">牛客
BM90</a></p>
<p>考察知识点：双指针、字符串、哈希</p>
<p>不知道有啥窍门，先写了一个比较暴力的。即检索以某处字符开头的最小覆盖子串。如果第一个字符不是目标字符串中的字符，那它肯定不是最小覆盖子串，因为去掉它也是可以的，这里应该是有最优子结构在的。然后就是逐个匹配，用哈希表一个个把字符消除掉，一直消除到字典是空的就说明字符攒够了，也即找到了以该位置开头的最小覆盖子串。然后需要找n次，所以最后复杂度应该是每次查找要<span
class="math inline">\(O(n)\)</span>然后要找n次，复杂度为<span
class="math inline">\(O(n^2)\)</span>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param S string字符串 </span></span><br><span class="line"><span class="comment"># @param T string字符串 </span></span><br><span class="line"><span class="comment"># @return string字符串</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minWindow</span>(<span class="params">self , S: <span class="built_in">str</span>, T: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        n = <span class="built_in">len</span>(S)</span><br><span class="line">        T_dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> T:</span><br><span class="line">            T_dict[t] = T_dict.get(t, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        min_length = <span class="number">10000</span></span><br><span class="line">        target_str = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> S[i] <span class="keyword">not</span> <span class="keyword">in</span> T_dict:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            char_set = T_dict.copy()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 一直往后搜索直到char_set第一次为空</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, n):</span><br><span class="line">                <span class="keyword">if</span> S[j] <span class="keyword">in</span> char_set <span class="keyword">and</span> char_set[S[j]] &gt; <span class="number">1</span>:</span><br><span class="line">                    char_set[S[j]] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> S[j] <span class="keyword">in</span> char_set <span class="keyword">and</span> char_set[S[j]] == <span class="number">1</span>:</span><br><span class="line">                    char_set.pop(S[j])</span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">len</span>(char_set) == <span class="number">0</span>:</span><br><span class="line">                        <span class="comment"># 空了就说明到以该字符开头的最短位置了</span></span><br><span class="line">                        <span class="keyword">if</span> j - i + <span class="number">1</span> &lt; min_length:</span><br><span class="line">                            target_str = S[i: j+<span class="number">1</span>]</span><br><span class="line">                            min_length = j - i + <span class="number">1</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> target_str <span class="keyword">if</span> min_length &lt; <span class="number">10000</span> <span class="keyword">else</span> <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h1 id="月6日">10月6日</h1>
<h2 id="bm-90-最小覆盖子串-1">BM 90 最小覆盖子串</h2>
<p>url：<a
target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/c466d480d20c4c7c9d322d12ca7955ac">牛客
BM90</a></p>
<p>考察知识点：双指针、字符串、哈希</p>
<p>不知道有啥窍门，先写了一个比较暴力的。即检索以某处字符开头的最小覆盖子串。如果第一个字符不是目标字符串中的字符，那它肯定不是最小覆盖子串，因为去掉它也是可以的，这里应该是有最优子结构在的。然后就是逐个匹配，用哈希表一个个把字符消除掉，一直消除到字典是空的就说明字符攒够了，也即找到了以该位置开头的最小覆盖子串。然后需要找n次，所以最后复杂度应该是每次查找要<span
class="math inline">\(O(n)\)</span>然后要找n次，复杂度为<span
class="math inline">\(O(n^2)\)</span>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param S string字符串 </span></span><br><span class="line"><span class="comment"># @param T string字符串 </span></span><br><span class="line"><span class="comment"># @return string字符串</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minWindow</span>(<span class="params">self , S: <span class="built_in">str</span>, T: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        n = <span class="built_in">len</span>(S)</span><br><span class="line">        T_dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> T:</span><br><span class="line">            T_dict[t] = T_dict.get(t, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        min_length = <span class="number">10000</span></span><br><span class="line">        target_str = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> S[i] <span class="keyword">not</span> <span class="keyword">in</span> T_dict:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            char_set = T_dict.copy()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 一直往后搜索直到char_set第一次为空</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, n):</span><br><span class="line">                <span class="keyword">if</span> S[j] <span class="keyword">in</span> char_set <span class="keyword">and</span> char_set[S[j]] &gt; <span class="number">1</span>:</span><br><span class="line">                    char_set[S[j]] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> S[j] <span class="keyword">in</span> char_set <span class="keyword">and</span> char_set[S[j]] == <span class="number">1</span>:</span><br><span class="line">                    char_set.pop(S[j])</span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">len</span>(char_set) == <span class="number">0</span>:</span><br><span class="line">                        <span class="comment"># 空了就说明到以该字符开头的最短位置了</span></span><br><span class="line">                        <span class="keyword">if</span> j - i + <span class="number">1</span> &lt; min_length:</span><br><span class="line">                            target_str = S[i: j+<span class="number">1</span>]</span><br><span class="line">                            min_length = j - i + <span class="number">1</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> target_str <span class="keyword">if</span> min_length &lt; <span class="number">10000</span> <span class="keyword">else</span> <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>接着10月2日之后来做吧，看了一下题解，发现这个维护双指针的方法真的非常巧妙。大体的做法就是右指针先移到满足条件的位置，然后左指针收缩到不能再收缩，这时候就获得了以右指针元素结尾的最短子串。这里面它多用了一个先验，就是如果左、右指针的位置已经能构成最小覆盖子串了，那右指针后面的最小覆盖子串都可以从左指针的位置开始收缩，因为左指针前面的元素都可以去掉。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param S string字符串 </span></span><br><span class="line"><span class="comment"># @param T string字符串 </span></span><br><span class="line"><span class="comment"># @return string字符串</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minWindow</span>(<span class="params">self , S: <span class="built_in">str</span>, T: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># 收缩窗口法</span></span><br><span class="line">        <span class="comment"># 核心是右指针一直移到满足条件的位置，然后驱动左指针收缩</span></span><br><span class="line">        <span class="comment"># 先建立字符哈希表</span></span><br><span class="line">        char_dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> T:</span><br><span class="line">            char_dict[char] = char_dict.get(char, <span class="number">0</span>) - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        n = <span class="built_in">len</span>(S)</span><br><span class="line">        min_length = <span class="number">10001</span></span><br><span class="line">        target = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> right &lt; n:</span><br><span class="line">            <span class="keyword">if</span> S[right] <span class="keyword">in</span> char_dict:</span><br><span class="line">                char_dict[S[right]] += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 验证当前字符串中是否已经包含所有字符了</span></span><br><span class="line">                complete = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">for</span> char <span class="keyword">in</span> char_dict:</span><br><span class="line">                    <span class="keyword">if</span> char_dict[char] &lt; <span class="number">0</span>:</span><br><span class="line">                        complete = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 如果当前已经完成的话就收缩左指针</span></span><br><span class="line">                <span class="keyword">if</span> complete:</span><br><span class="line">                    <span class="keyword">while</span> S[left] <span class="keyword">not</span> <span class="keyword">in</span> char_dict <span class="keyword">or</span> char_dict[S[left]] &gt;= <span class="number">1</span>:</span><br><span class="line">                        <span class="keyword">if</span> S[left] <span class="keyword">in</span> char_dict:</span><br><span class="line">                            char_dict[S[left]] -= <span class="number">1</span></span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">                        </span><br><span class="line">                    <span class="comment"># 这里就是以right指针结尾的最小覆盖子串了</span></span><br><span class="line">                    <span class="keyword">if</span> right - left + <span class="number">1</span> &lt; min_length:</span><br><span class="line">                        min_length = right - left + <span class="number">1</span></span><br><span class="line">                        target = S[left: right + <span class="number">1</span>]</span><br><span class="line">            </span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> target</span><br></pre></td></tr></table></figure>
<h2 id="bm-91-反转字符串">BM 91 反转字符串</h2>
<p>url：<a
target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/c3a6afee325e472386a1c4eb1ef987f3">牛客
BM91</a></p>
<p>考察知识点：字符串</p>
<p>还是比较基础的，甚至直接调用reverse就能反转过来，如果不讲究就像这样开个数组拼一下行了。但是对Python来说字符串是不可变的，因此不能像Java那样交换字符串的位置。要新开一个列表的话那就按逆序加入元素即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 反转字符串</span></span><br><span class="line"><span class="comment"># @param str string字符串 </span></span><br><span class="line"><span class="comment"># @return string字符串</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">solve</span>(<span class="params">self , str1: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        str_list = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> str1:</span><br><span class="line">            str_list.insert(<span class="number">0</span>, char)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(str_list)</span><br></pre></td></tr></table></figure>
<h2 id="bm-92-最长无重复子数组">BM 92 最长无重复子数组</h2>
<p>url：<a
target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/b56799ebfd684fb394bd315e89324fb4">牛客
BM92</a></p>
<p>考察知识点：哈希、双指针、数组</p>
<p>其实和BM90很类似，都是对所谓“子数组”的限制。这类问题一般可以抽象成一个滑动窗口，滑动窗口里维护一个字典或者集合，每次指针移动时就在字典或集合里更新现在字符串的状态。实现如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param arr int整型一维数组 the array</span></span><br><span class="line"><span class="comment"># @return int整型</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxLength</span>(<span class="params">self , arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        T = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        n = <span class="built_in">len</span>(arr)</span><br><span class="line">        max_length = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> right &lt; n:</span><br><span class="line">            <span class="keyword">if</span> arr[right] <span class="keyword">in</span> T:</span><br><span class="line">                <span class="comment"># 如果到这了说明已经出现重复了，要开始统计以right-1结尾的子数组长度了</span></span><br><span class="line">                <span class="comment"># 结算从left到right-1的子数组长度</span></span><br><span class="line">                <span class="keyword">if</span> right - left &gt; max_length:</span><br><span class="line">                    max_length = right - left</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 收缩left指针以便能加入right位置的元素</span></span><br><span class="line">                <span class="keyword">while</span> arr[left] != arr[right]:</span><br><span class="line">                    T.remove(arr[left])</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 如果left不等于right的话依然要右移一位</span></span><br><span class="line">                <span class="comment"># 但反之则不需要</span></span><br><span class="line">                <span class="keyword">if</span> left != right:</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 没有触发相同时就一直向后移动直到退出</span></span><br><span class="line">                T.add(arr[right])</span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 结束时也需要额外判断一下</span></span><br><span class="line">        <span class="keyword">if</span> right - left &gt; max_length:</span><br><span class="line">            max_length = right - left</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max_length</span><br></pre></td></tr></table></figure>
<p>大体做法就是right指针一直移动，直到发现right位置当前元素不能加入子数组为止。这时候以left开头的最长无重复子数组已经找出来了，就是从left到right-1里的所有元素构成的子数组。然后，我们需要收缩left指针，一直收缩到和right位置元素相同的元素位置为止，因为只有去掉这个元素，right位置的元素才能加入子数组。当然也有一个特殊情况，就是left已经缩到和right一样了，那left也不用继续缩了，因为此时就一个元素了。</p>
<h2 id="bm-93-盛水最多的容器">BM 93 盛水最多的容器</h2>
<p>url：<a
target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/3d8d6a8e516e4633a2244d2934e5aa47">牛客
BM93</a></p>
<p>考察知识点：双指针、数组、贪心算法</p>
<p>这题感觉比较难，一般的思路肯定就是先确定左边的木板，然后再确定右边的木板，遍历的话要<span
class="math inline">\(O(n^2)\)</span>的复杂度。写了之后发现过不了，然后又加了一些优化，结果还是超时。实现如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param height int整型一维数组 </span></span><br><span class="line"><span class="comment"># @return int整型</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxArea</span>(<span class="params">self , height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        n = <span class="built_in">len</span>(height)</span><br><span class="line">        max_area = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, h1 <span class="keyword">in</span> <span class="built_in">enumerate</span>(height):</span><br><span class="line">            <span class="comment"># 提前退出</span></span><br><span class="line">            <span class="keyword">if</span> h1 * (n - i) &lt; max_area:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>, i, -<span class="number">1</span>):</span><br><span class="line">                h = <span class="built_in">min</span>(h1, height[j])</span><br><span class="line">                l = j - i</span><br><span class="line">                <span class="keyword">if</span> h * l &gt; max_area:</span><br><span class="line">                    max_area = h * l</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 如果倒序遇到比它长的右木板了那之后的不用看了</span></span><br><span class="line">                <span class="comment"># 肯定是没这个容器能装的</span></span><br><span class="line">                <span class="keyword">if</span> height[j] &gt;= h1 <span class="keyword">or</span> h1 * (j - i) &lt; max_area:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max_area</span><br></pre></td></tr></table></figure>
<p>看了题解之后才知道，这题实际上隐含了一个最优子结构。假设我们已经找到了一个最大容积的容器，那在左边木板的左边部分不可能有不低于左木板的元素，同样右边部分不可能有低于右木板的元素。也就意味着如果我们从两端开始，然后尽可能地保留长边替换短边，是可以得到最优解的。因此，从左右两边开始，每次都把短的那边换成下一个边，往复直到左右指针相遇就可以获得最大容积的容器了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param height int整型一维数组 </span></span><br><span class="line"><span class="comment"># @return int整型</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxArea</span>(<span class="params">self , height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        n = <span class="built_in">len</span>(height)</span><br><span class="line">        max_area = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(height) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            h = <span class="built_in">min</span>(height[left], height[right])</span><br><span class="line">            l = right - left</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> h * l &gt; max_area:</span><br><span class="line">                max_area = h * l</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 换边，看哪边短换哪边</span></span><br><span class="line">            <span class="keyword">if</span> height[left] &lt; height[right]:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max_area</span><br></pre></td></tr></table></figure>
<p>这个确实很巧妙，解法出来之后我还感觉会不会不能保证最优，想到容器左右两边都不可能有比它们高的元素了才觉得确实是合理的。</p>
<h1 id="月9日">10月9日</h1>
<h2 id="bm-94-接雨水问题">BM 94 接雨水问题</h2>
<p>url：<a
target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/31c1aed01b394f0b8b7734de0324e00f">牛客
BM94</a></p>
<p>考察知识点：双指针、动态规划</p>
<p>这题的常规思路就是双指针，和<a
target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/3d8d6a8e516e4633a2244d2934e5aa47">牛客
BM93</a>类似，只不过现在底不是平的了，而且是要求所有桶能盛下的水。</p>
<p>可以这样思考，最开始左右两边肯定盛不了水，但它们可以作为桶的边。每次移动高度低的那边指针，并且观察新的位置是否超出桶的高度了，如果超出了则说明进入了一个新的桶，更新桶的高度。否则，就还在那个桶里面，更新雨水的量。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># max water</span></span><br><span class="line"><span class="comment"># @param arr int整型一维数组 the array</span></span><br><span class="line"><span class="comment"># @return long长整型</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxWater</span>(<span class="params">self , arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        n = <span class="built_in">len</span>(arr)</span><br><span class="line">        left, right = <span class="number">0</span>, n-<span class="number">1</span></span><br><span class="line">        water = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 桶的高度</span></span><br><span class="line">        h = <span class="built_in">min</span>(arr[left], arr[right])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="keyword">if</span> arr[left] &lt; arr[right]:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> arr[left] &lt; h:</span><br><span class="line">                    <span class="comment"># 现在仍然在桶里面</span></span><br><span class="line">                    water += h - arr[left]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 否则说明要更新桶的高度了</span></span><br><span class="line">                    h = <span class="built_in">min</span>(arr[left], arr[right])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> arr[right] &lt; h:</span><br><span class="line">                    <span class="comment"># 现在仍然在桶里面</span></span><br><span class="line">                    water += h - arr[right]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 否则说明要更新桶的高度了</span></span><br><span class="line">                    h = <span class="built_in">min</span>(arr[left], arr[right])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> water</span><br></pre></td></tr></table></figure>
<p>另外一种办法就是先求出最高的柱子，然后以最高柱子为支点将原问题切分为左、右两个子问题。这样的好处就是简化思考，左边的子问题永远不需要动右边的柱子，只需要遇到比左边柱子高的值后将柱子更新过去即可，右边也是同理，不过要倒序遍历一下。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># max water</span></span><br><span class="line"><span class="comment"># @param arr int整型一维数组 the array</span></span><br><span class="line"><span class="comment"># @return long长整型</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxWater</span>(<span class="params">self , arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        n = <span class="built_in">len</span>(arr)</span><br><span class="line">        water = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 先找最高的柱子，把问题分解为左右两边的子问题</span></span><br><span class="line">        top = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> arr[i] &gt; arr[top]:</span><br><span class="line">                top = i</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 考虑top柱子左边的问题</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(top):</span><br><span class="line">            <span class="keyword">if</span> arr[i] &gt;= arr[left]:</span><br><span class="line">                <span class="comment"># 更新左边的柱子</span></span><br><span class="line">                left = i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                water += arr[left] - arr[i]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 考虑top柱子右边的问题</span></span><br><span class="line">        right = n-<span class="number">1</span></span><br><span class="line">        <span class="comment"># 倒序遍历</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">2</span>, top, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> arr[i] &gt;= arr[right]:</span><br><span class="line">                <span class="comment"># 更新右边的柱子</span></span><br><span class="line">                right = i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                water += arr[right] - arr[i]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> water</span><br></pre></td></tr></table></figure>
<p>动态规划的思路也很巧妙，就是如果一个位置要盛水，那肯定是在它左边和右边都有比它更高的柱子，它能装下的水的高度是左边和右边最高柱子的较小值。那么如果我们用一个dp数组维护该位置左边和该位置右边的最高柱子高度，那计算时只需要求二者的最小值然后判断与当前高度的相对大小关系即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># max water</span></span><br><span class="line"><span class="comment"># @param arr int整型一维数组 the array</span></span><br><span class="line"><span class="comment"># @return long长整型</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxWater</span>(<span class="params">self , arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        n = <span class="built_in">len</span>(arr)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># dp[i][0]代表i位置前面（不包括自身）最高的柱子</span></span><br><span class="line">        <span class="comment"># dp[i][1]代表i位置后面（不包括自身）最高的柱子</span></span><br><span class="line">        dp = [[<span class="number">0</span>, <span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">0</span>], arr[i-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            dp[j][<span class="number">1</span>] = <span class="built_in">max</span>(dp[j+<span class="number">1</span>][<span class="number">1</span>], arr[j+<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        water = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            h = <span class="built_in">min</span>(dp[i][<span class="number">0</span>], dp[i][<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> h &gt; arr[i]:</span><br><span class="line">                water += h - arr[i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> water   </span><br></pre></td></tr></table></figure>
<h2 id="bm-95-分糖果问题">BM 95 分糖果问题</h2>
<p>url：<a
target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/76039109dd0b47e994c08d8319faa352">牛客
BM95</a></p>
<p>考察知识点：贪心算法</p>
<p>先从右边倒数第二个人开始与右边的人比，如果分数多于右边而且糖果不多于右边就更新糖果为右边的糖果数+1。左边也类似，从左边第二个人开始与左边的人比，如果分数多于左边而且糖果不多于左边就更新糖果为左边的糖果数+1。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># pick candy</span></span><br><span class="line"><span class="comment"># @param arr int整型一维数组 the array</span></span><br><span class="line"><span class="comment"># @return int整型</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">candy</span>(<span class="params">self , arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        n = <span class="built_in">len</span>(arr)</span><br><span class="line">        <span class="comment"># 糖果数组</span></span><br><span class="line">        c = [<span class="number">1</span>] * n</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 从最右边开始与右边的人比糖果多少</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> arr[i] &gt; arr[i+<span class="number">1</span>] <span class="keyword">and</span> c[i] &lt;= c[i+<span class="number">1</span>]:</span><br><span class="line">                c[i] = c[i+<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 再从最左边开始与左边的人比糖果多少</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> arr[j] &gt; arr[j-<span class="number">1</span>] <span class="keyword">and</span> c[j] &lt;= c[j-<span class="number">1</span>]:</span><br><span class="line">                c[j] = c[j-<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(c)</span><br></pre></td></tr></table></figure>
<h2 id="bm-96-主持人调度二">BM 96 主持人调度（二）</h2>
<p>url：<a
target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/4edf6e6d01554870a12f218c94e8a299">牛客
BM95</a></p>
<p>考察知识点：贪心算法、堆</p>
<p>大体做法就是先按开始时间将活动排序，之后安排主持人。安排过的主持人结束时间记录在一个小根堆中，然后每次要安排新主持人前查看是否有已经结束的主持人将已经结束的主持人重新加回来，之后再分配主持人。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 计算成功举办活动需要多少名主持人</span></span><br><span class="line"><span class="comment"># @param n int整型 有n个活动</span></span><br><span class="line"><span class="comment"># @param startEnd int整型二维数组 startEnd[i][0]用于表示第i个活动的开始时间，startEnd[i][1]表示第i个活动的结束时间</span></span><br><span class="line"><span class="comment"># @return int整型</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minmumNumberOfHost</span>(<span class="params">self , n: <span class="built_in">int</span>, startEnd: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># 按开始时间排序</span></span><br><span class="line">        startEnd.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 当前剩余的主持人数量和总主持人数量</span></span><br><span class="line">        cur_num = <span class="number">0</span></span><br><span class="line">        all_num = <span class="number">0</span></span><br><span class="line">        end_time = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="comment"># 上岗时间</span></span><br><span class="line">            cur = startEnd[i][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 归还上次活动结束的主持人</span></span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(end_time) &gt; <span class="number">0</span> <span class="keyword">and</span> end_time[<span class="number">0</span>] &lt;= cur:</span><br><span class="line">                cur_num += <span class="number">1</span></span><br><span class="line">                heapq.heappop(end_time)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 结算主持人数量</span></span><br><span class="line">            <span class="keyword">if</span> cur_num == <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 如果现在没有主持人就要新增主持人</span></span><br><span class="line">                all_num += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 有的话就先用着现有主持人</span></span><br><span class="line">                cur_num -= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 记录归还时间</span></span><br><span class="line">            heapq.heappush(end_time, startEnd[i][<span class="number">1</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> all_num</span><br></pre></td></tr></table></figure>
<h2 id="bm-97-旋转数组">BM 97 旋转数组</h2>
<p>url：<a
target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/e19927a8fd5d477794dac67096862042">牛客
BM97</a></p>
<p>考察知识点：数组</p>
<p>如果没做过这道题，真的很难想明白旋转数组该怎么转！如果一直挪那个旧数组的话会发现怎么挪也挪不对。</p>
<p>看了题解之后发现3次翻转旧等同于进行这样的旋转了。第一步会把整个数组反转，之后把前m个元素反转，再之后把后n-m个元素反转即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 旋转数组</span></span><br><span class="line"><span class="comment"># @param n int整型 数组长度</span></span><br><span class="line"><span class="comment"># @param m int整型 右移距离</span></span><br><span class="line"><span class="comment"># @param a int整型一维数组 给定数组</span></span><br><span class="line"><span class="comment"># @return int整型一维数组</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">solve</span>(<span class="params">self , n: <span class="built_in">int</span>, m: <span class="built_in">int</span>, a: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># 如果循环次数超过n，则取余数即可</span></span><br><span class="line">        m = m % n</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 先把整个数组反转</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n // <span class="number">2</span>):</span><br><span class="line">            a[i], a[n-i-<span class="number">1</span>] = a[n-i-<span class="number">1</span>], a[i]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 翻转前m个元素</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m // <span class="number">2</span>):</span><br><span class="line">            a[i], a[m-i-<span class="number">1</span>] = a[m-i-<span class="number">1</span>], a[i]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 翻转后m+1到n的元素</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m, (n+m)//<span class="number">2</span>):</span><br><span class="line">            a[i], a[n+m-i-<span class="number">1</span>] = a[n+m-i-<span class="number">1</span>], a[i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure>
<h2 id="bm-98-螺旋矩阵">BM 98 螺旋矩阵</h2>
<p>url：<a
target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/7edf70f2d29c4b599693dc3aaeea1d31">牛客
BM98</a></p>
<p>考察知识点：数组</p>
<p>用一个矩阵记录是否访问过该元素，然后按向右走、向下走、向左走和向上走的流程来模拟螺旋数组的过程。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param matrix int整型二维数组 </span></span><br><span class="line"><span class="comment"># @return int整型一维数组</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">spiralOrder</span>(<span class="params">self , matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        m = <span class="built_in">len</span>(matrix)</span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        n = <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        visited = [[<span class="literal">False</span>]*n <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line"></span><br><span class="line">        result = []</span><br><span class="line">        i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> i &lt; m <span class="keyword">and</span> j &lt; n <span class="keyword">and</span> <span class="keyword">not</span> visited[i][j]:</span><br><span class="line">            <span class="comment"># 先向右走</span></span><br><span class="line">            <span class="keyword">while</span> j &lt; n <span class="keyword">and</span> <span class="keyword">not</span> visited[i][j]:</span><br><span class="line">                result.append(matrix[i][j])</span><br><span class="line">                visited[i][j] = <span class="literal">True</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 再向下走</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; m <span class="keyword">and</span> <span class="keyword">not</span> visited[i][j]:</span><br><span class="line">                result.append(matrix[i][j])</span><br><span class="line">                visited[i][j] = <span class="literal">True</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">            <span class="comment"># 再向左走</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> visited[i][j]:</span><br><span class="line">                result.append(matrix[i][j])</span><br><span class="line">                visited[i][j] = <span class="literal">True</span></span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 再向上走</span></span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> visited[i][j]:</span><br><span class="line">                result.append(matrix[i][j])</span><br><span class="line">                visited[i][j] = <span class="literal">True</span></span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 进入下一圈</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p>每次都只有上下左右的边界会收缩，用<code>visited</code>这样的二维数组来记录是否访问确实有点浪费，实际上我们只需要<code>up</code>,
<code>down</code>, <code>right</code>,
<code>left</code>四个边界值记录边界即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param matrix int整型二维数组 </span></span><br><span class="line"><span class="comment"># @return int整型一维数组</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">spiralOrder</span>(<span class="params">self , matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        m = <span class="built_in">len</span>(matrix)</span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        n = <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 上下左右4个边界</span></span><br><span class="line">        up, down, left, right = <span class="number">0</span>, m-<span class="number">1</span>, <span class="number">0</span>, n-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        result = []</span><br><span class="line">        i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> i &lt;= down <span class="keyword">and</span> j &lt;= right:</span><br><span class="line">            <span class="comment"># 先向右走</span></span><br><span class="line">            <span class="keyword">while</span> j &lt;= right:</span><br><span class="line">                result.append(matrix[i][j])</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 上边界收缩，并复位到最后一列</span></span><br><span class="line">            up += <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> up &gt; down:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 再向下走</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt;= down:</span><br><span class="line">                result.append(matrix[i][j])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 右边界收缩，并复位到最后一行</span></span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> left &gt; right:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    </span><br><span class="line">            <span class="comment"># 再向左走</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &gt;= left:</span><br><span class="line">                result.append(matrix[i][j])</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># 下边界收缩</span></span><br><span class="line">            down -= <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> up &gt; down:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 再向上走</span></span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &gt;= up:</span><br><span class="line">                result.append(matrix[i][j])</span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># 左边界收缩</span></span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> left &gt; right:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 进入下一圈</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h2 id="bm-99-顺时针旋转矩阵">BM 99 顺时针旋转矩阵</h2>
<p>url：<a
target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/2e95333fbdd4451395066957e24909cc">牛客
BM99</a></p>
<p>考察知识点：数组</p>
<p>一个想法就是转置，之后行翻转就行了。转置时需要新申请一个和原矩阵一样的空间，所以空间复杂度达到<span
class="math inline">\(O(n^2)\)</span>，要操作每一个元素，时间复杂度为<span
class="math inline">\(O(n^2)\)</span>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param mat int整型二维数组 </span></span><br><span class="line"><span class="comment"># @param n int整型 </span></span><br><span class="line"><span class="comment"># @return int整型二维数组</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotateMatrix</span>(<span class="params">self , mat: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        rotate_mat = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            rotate_row = [mat[i][j] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">            rotate_row.reverse()</span><br><span class="line">            rotate_mat.append(rotate_row)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> rotate_mat</span><br></pre></td></tr></table></figure>
<p>另外一种思路就是先进行行翻转，然后我们会发现目标矩阵和现在矩阵的差距就是需要进行反对角线元素的交换，那我们按反对角线进行元素交换即可。这种方法依然需要<span
class="math inline">\(O(n^2)\)</span>级别的时间复杂度，但只需要<span
class="math inline">\(O(1)\)</span>的空间复杂度，因为不涉及新空间的申请。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param mat int整型二维数组 </span></span><br><span class="line"><span class="comment"># @param n int整型 </span></span><br><span class="line"><span class="comment"># @return int整型二维数组</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotateMatrix</span>(<span class="params">self , mat: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># 先把每行都反转一下</span></span><br><span class="line">        <span class="keyword">for</span> mat_row <span class="keyword">in</span> mat:</span><br><span class="line">            mat_row.reverse()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 按反对角线交换元素</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n-i-<span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="comment"># 交换关于反对角线对称的元素</span></span><br><span class="line">                mat[i][j], mat[n-j-<span class="number">1</span>][n-i-<span class="number">1</span>] = mat[n-j-<span class="number">1</span>][n-i-<span class="number">1</span>], mat[i][j]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> mat</span><br></pre></td></tr></table></figure>
<p>看了题解之后发现自己多此一举了，转置不需要新申请数组也可以做呀，就是沿对角线交换，沿对角线交换的下标表示要简单很多。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param mat int整型二维数组 </span></span><br><span class="line"><span class="comment"># @param n int整型 </span></span><br><span class="line"><span class="comment"># @return int整型二维数组</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotateMatrix</span>(<span class="params">self , mat: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># 按对角线交换元素就是转置！</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, n):</span><br><span class="line">                <span class="comment"># 交换关于对角线对称的元素</span></span><br><span class="line">                mat[i][j], mat[j][i] = mat[j][i], mat[i][j]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 先把每行都反转一下</span></span><br><span class="line">        <span class="keyword">for</span> mat_row <span class="keyword">in</span> mat:</span><br><span class="line">            mat_row.reverse()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> mat</span><br></pre></td></tr></table></figure>
<h1 id="月10日">10月10日</h1>
<h2 id="bm-100-设计lru缓存">BM 100 设计LRU缓存</h2>
<p>url：<a
target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/5dfded165916435d9defb053c63f1e84">牛客
BM100</a></p>
<p>考察知识点：链表、哈希、模拟</p>
<p>这题的关键在于怎么标识最近最少使用的元素，而且需要以<span
class="math inline">\(O(1)\)</span>的复杂度来更新这个最近最少使用的状态结构。数组肯定是不行的，因为数组删除中间一个元素之后不可避免地会引起后面元素位置的移动。纯链表结构也不行，因为这样更新已有key的状态的时候还需要在链表里找那个元素，这样都会使最坏时间复杂度来到<span
class="math inline">\(O(n)\)</span>级别。</p>
<p>一种可行的办法是使用链表和字典配合来维护最近最少使用的元素，越靠近头节点的元素最近使用得越少，越靠近尾节点的元素最近使用得越频繁。在使用已有key时可用通过哈希表快速获得已有链表节点的引用，并将该节点插入到尾节点前面。</p>
<p>还有一个需要注意的点是LRU结构中，get和set方法都会更新节点使用情况。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, data</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        self.prev = <span class="literal">None</span></span><br><span class="line">        self.key = data</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, capacity: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        self.capacity = capacity</span><br><span class="line">        self.key_value_dict = &#123;&#125;</span><br><span class="line">        <span class="comment"># 创建最近使用的链表</span></span><br><span class="line">        self.list_head = ListNode(<span class="literal">None</span>)</span><br><span class="line">        self.list_tail = ListNode(<span class="literal">None</span>)</span><br><span class="line">        self.list_head.<span class="built_in">next</span> = self.list_tail</span><br><span class="line">        self.list_tail.prev = self.list_head</span><br><span class="line">        <span class="comment"># 记录每个键对应值的引用</span></span><br><span class="line">        self.key_pos = &#123;&#125;</span><br><span class="line">        <span class="comment"># 目前结构中键的数量</span></span><br><span class="line">        self.num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># get操作也会刷新缓存!</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.key_pos:</span><br><span class="line">            update_node = self.key_pos[key]</span><br><span class="line">            <span class="comment"># 取出该元素并移到链表末尾</span></span><br><span class="line">            update_node.<span class="built_in">next</span>.prev = update_node.prev</span><br><span class="line">            update_node.prev.<span class="built_in">next</span> = update_node.<span class="built_in">next</span></span><br><span class="line">            update_node.<span class="built_in">next</span> = self.list_tail</span><br><span class="line">            update_node.prev = self.list_tail.prev</span><br><span class="line">            self.list_tail.prev.<span class="built_in">next</span> = update_node</span><br><span class="line">            self.list_tail.prev = update_node</span><br><span class="line">        <span class="keyword">return</span> self.key_value_dict.get(key, -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set</span>(<span class="params">self, key: <span class="built_in">int</span>, value: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> self.num == self.capacity <span class="keyword">and</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.key_value_dict:</span><br><span class="line">            <span class="comment"># 如果满了要执行删除操作</span></span><br><span class="line">            <span class="comment"># 取出待删除的元素引用</span></span><br><span class="line">            node = self.list_head.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># 先把该元素从链表中取出来，并重新链接剩余链表元素</span></span><br><span class="line">            node.prev.<span class="built_in">next</span> = node.<span class="built_in">next</span></span><br><span class="line">            node.<span class="built_in">next</span>.prev = node.prev</span><br><span class="line">            <span class="comment"># 删除该元素</span></span><br><span class="line">            self.key_pos.pop(node.key)</span><br><span class="line">            self.key_value_dict.pop(node.key)</span><br><span class="line">            self.num -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 为新元素计数并加入链表，为旧元素更新位置</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.key_value_dict:</span><br><span class="line">            self.num += <span class="number">1</span></span><br><span class="line">            insert_node = ListNode(key)</span><br><span class="line">            <span class="comment"># 插入链表尾节点前面</span></span><br><span class="line">            insert_node.prev = self.list_tail.prev</span><br><span class="line">            insert_node.<span class="built_in">next</span> = self.list_tail</span><br><span class="line">            self.list_tail.prev.<span class="built_in">next</span> = insert_node</span><br><span class="line">            self.list_tail.prev = insert_node</span><br><span class="line">            <span class="comment"># 更新该元素引用到位置字典中</span></span><br><span class="line">            self.key_pos[key] = insert_node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 旧元素记得更新链表节点位置到链表尾部</span></span><br><span class="line">            update_node = self.key_pos[key]</span><br><span class="line">            <span class="comment"># 取出链表元素</span></span><br><span class="line">            update_node.prev.<span class="built_in">next</span> = update_node.<span class="built_in">next</span></span><br><span class="line">            update_node.<span class="built_in">next</span>.prev = update_node.prev</span><br><span class="line">            <span class="comment"># 插入链表尾节点前面</span></span><br><span class="line">            update_node.<span class="built_in">next</span> = self.list_tail</span><br><span class="line">            update_node.prev = self.list_tail.prev</span><br><span class="line">            self.list_tail.prev.<span class="built_in">next</span> = update_node</span><br><span class="line">            self.list_tail.prev = update_node</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 设置新元素键和值</span></span><br><span class="line">        self.key_value_dict[key] = value</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># solution = Solution(capacity)</span></span><br><span class="line"><span class="comment"># output = solution.get(key)</span></span><br><span class="line"><span class="comment"># solution.set(key,value)</span></span><br></pre></td></tr></table></figure>
<h2 id="bm-101-设计lfu缓存结构">BM 101 设计LFU缓存结构</h2>
<p>url：<a
target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/93aacb4a887b46d897b00823f30bfea1">牛客
BM101</a></p>
<p>考察知识点：堆、哈希</p>
<p>我的实现是通过一个堆来记录插入元素的优先级，优先级低的就会被删除。为了实现先比较操作次数再比较操作时间，实现一个堆元素的对象并重写其<code>__lt__</code>来自定义比较行为。对于要修改堆中元素优先级的操作（比如获取LFU中已有元素或者更新LFU已有元素），采用Python文档里比较迂回的实现，即标记旧元素为删除后插入一个新的数据元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># lfu design</span></span><br><span class="line"><span class="comment"># @param operators int整型二维数组 ops</span></span><br><span class="line"><span class="comment"># @param k int整型 the k</span></span><br><span class="line"><span class="comment"># @return int整型一维数组</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HeapElement</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, call_num: <span class="built_in">int</span>, call_time: <span class="built_in">int</span>, key</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.call_num = call_num</span><br><span class="line">        self.call_time = call_time</span><br><span class="line">        self.key = key</span><br><span class="line">        self.delete = <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__lt__</span>(<span class="params">self, another</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(another, HeapElement):</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">f&quot;无法比较的类型: <span class="subst">&#123;<span class="built_in">type</span>(self)&#125;</span>, <span class="subst">&#123;<span class="built_in">type</span>(another)&#125;</span>&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 先比较调用次数，调用次数相同之后再比较调用时间</span></span><br><span class="line">        <span class="keyword">if</span> self.call_num == another.call_num:</span><br><span class="line">            <span class="keyword">return</span> self.call_time &lt; another.call_time</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.call_num &lt; another.call_num</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">LFU</span>(<span class="params">self , operators: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># 初始化堆，优先级为调用次数</span></span><br><span class="line">        heap = []</span><br><span class="line">        <span class="comment"># 保存堆中元素的引用</span></span><br><span class="line">        key2heap_element = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 保存键和值</span></span><br><span class="line">        key2value = &#123;&#125;</span><br><span class="line">        <span class="comment"># 总容量和当前键数目</span></span><br><span class="line">        capacity, key_num = k, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 保存结果</span></span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, op <span class="keyword">in</span> <span class="built_in">enumerate</span>(operators):</span><br><span class="line">            <span class="keyword">if</span> op[<span class="number">0</span>] == <span class="number">1</span>:</span><br><span class="line">                <span class="comment"># 插入操作</span></span><br><span class="line">                key, value = op[<span class="number">1</span>], op[<span class="number">2</span>]</span><br><span class="line">                <span class="comment"># 观察一下当前结构是否已满</span></span><br><span class="line">                <span class="keyword">if</span> key_num == capacity <span class="keyword">and</span> key <span class="keyword">not</span> <span class="keyword">in</span> key2value:</span><br><span class="line">                    <span class="comment"># 这一步是要先删除元素了</span></span><br><span class="line">                    heap_element = heapq.heappop(heap)</span><br><span class="line">                    <span class="keyword">while</span> heap_element.delete:</span><br><span class="line">                        <span class="comment"># 一直弹出直到遇到有效元素</span></span><br><span class="line">                        heap_element = heapq.heappop(heap)</span><br><span class="line">                    <span class="comment"># 删除相应元素</span></span><br><span class="line">                    key2value.pop(heap_element.key)</span><br><span class="line">                    key_num -= <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> key <span class="keyword">in</span> key2value:</span><br><span class="line">                    <span class="comment"># 如果已经有这个值了需要执行更新操作</span></span><br><span class="line">                    <span class="comment"># 似乎没办法确定位置，因此使用删除标记删除旧元素</span></span><br><span class="line">                    <span class="comment"># 并且新建一个元素插入堆中</span></span><br><span class="line">                    update_element = key2heap_element.pop(key)</span><br><span class="line">                    new_element = HeapElement(update_element.call_num + <span class="number">1</span>, i, key)</span><br><span class="line">                    update_element.delete = <span class="literal">True</span></span><br><span class="line">                    <span class="comment"># 更新入堆</span></span><br><span class="line">                    heapq.heappush(heap, new_element)</span><br><span class="line">                    key2heap_element[key] = new_element</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 没有的话执行插入即可</span></span><br><span class="line">                    new_element = HeapElement(<span class="number">1</span>, i, key)</span><br><span class="line">                    heapq.heappush(heap, new_element)</span><br><span class="line">                    key2heap_element[key] = new_element</span><br><span class="line">                    <span class="comment"># 更新键数量</span></span><br><span class="line">                    key_num += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 更新值</span></span><br><span class="line">                key2value[key] = value</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 这里是get操作</span></span><br><span class="line">                key = op[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> key <span class="keyword">in</span> key2value:</span><br><span class="line">                    <span class="comment"># 如果这个键是旧的，那需要更新一下优先级</span></span><br><span class="line">                    update_element = key2heap_element.pop(key)</span><br><span class="line">                    new_element = HeapElement(update_element.call_num + <span class="number">1</span>, i, key)</span><br><span class="line">                    update_element.delete = <span class="literal">True</span></span><br><span class="line">                    <span class="comment"># 更新入堆</span></span><br><span class="line">                    heapq.heappush(heap, new_element)</span><br><span class="line">                    key2heap_element[key] = new_element</span><br><span class="line">                </span><br><span class="line">                res.append(key2value.get(key, -<span class="number">1</span>))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>这个方法有个不好的点就是这边的堆在需要更新元素频率时是插入新元素并把旧元素标记为删除的。这在插入时依然能保持<span
class="math inline">\(O(\log
n)\)</span>的复杂度，但是当需要从堆中弹出元素删除时，可能需要多次弹出被删除的元素，每次堆的弹出操作需要<span
class="math inline">\(O(\log
n)\)</span>的时间复杂度，所以最坏情况下可能会超过<span
class="math inline">\(O(\log n)\)</span>的时间复杂度。</p>
<p>题解的做法是维护了一个最小频率的队列，但是从这个队列里面删除元素需要遍历一遍这个队列，假设所有已有元素频率都是1，那么更新一个键的频率的复杂度也可能达到<span
class="math inline">\(O(n)\)</span>，似乎没办法总是保证插入和获取键的最坏时间复杂度控制在<span
class="math inline">\(O(\log n)\)</span>。该方法实现如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># lfu design</span></span><br><span class="line"><span class="comment"># @param operators int整型二维数组 ops</span></span><br><span class="line"><span class="comment"># @param k int整型 the k</span></span><br><span class="line"><span class="comment"># @return int整型一维数组</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HeapElement</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, call_num: <span class="built_in">int</span>, call_time: <span class="built_in">int</span>, key</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.call_num = call_num</span><br><span class="line">        self.call_time = call_time</span><br><span class="line">        self.key = key</span><br><span class="line">        self.delete = <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__lt__</span>(<span class="params">self, another</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(another, HeapElement):</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">f&quot;无法比较的类型: <span class="subst">&#123;<span class="built_in">type</span>(self)&#125;</span>, <span class="subst">&#123;<span class="built_in">type</span>(another)&#125;</span>&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 先比较调用次数，调用次数相同之后再比较调用时间</span></span><br><span class="line">        <span class="keyword">if</span> self.call_num == another.call_num:</span><br><span class="line">            <span class="keyword">return</span> self.call_time &lt; another.call_time</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.call_num &lt; another.call_num</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">LFU</span>(<span class="params">self , operators: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># 频率字典</span></span><br><span class="line">        freq2keys = &#123;&#125;</span><br><span class="line">        key2freq = &#123;&#125;</span><br><span class="line">        <span class="comment"># 最低频率</span></span><br><span class="line">        min_freq = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 保存键和值</span></span><br><span class="line">        key2value = &#123;&#125;</span><br><span class="line">        <span class="comment"># 总容量和当前键数目</span></span><br><span class="line">        capacity, key_num = k, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 保存结果</span></span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, op <span class="keyword">in</span> <span class="built_in">enumerate</span>(operators):</span><br><span class="line">            <span class="keyword">if</span> op[<span class="number">0</span>] == <span class="number">1</span>:</span><br><span class="line">                <span class="comment"># 插入操作</span></span><br><span class="line">                key, value = op[<span class="number">1</span>], op[<span class="number">2</span>]</span><br><span class="line">                <span class="comment"># 观察一下当前结构是否已满</span></span><br><span class="line">                <span class="keyword">if</span> key_num == capacity <span class="keyword">and</span> key <span class="keyword">not</span> <span class="keyword">in</span> key2value:</span><br><span class="line">                    <span class="comment"># 这一步是要先删除元素了</span></span><br><span class="line">                    remove_key = freq2keys[min_freq].pop(<span class="number">0</span>)</span><br><span class="line">                    <span class="comment"># 删除相应元素</span></span><br><span class="line">                    key2value.pop(remove_key)</span><br><span class="line">                    key2freq.pop(remove_key)</span><br><span class="line">                    key_num -= <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> key <span class="keyword">in</span> key2value:</span><br><span class="line">                    <span class="comment"># 如果已经有这个值了需要执行更新操作</span></span><br><span class="line">                    <span class="comment"># 将数组元素元素从原位置移出</span></span><br><span class="line">                    freq = key2freq[key]</span><br><span class="line">                    freq2keys[freq].remove(key)</span><br><span class="line">                    <span class="comment"># 更新入新数组</span></span><br><span class="line">                    freq = freq + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> freq <span class="keyword">not</span> <span class="keyword">in</span> freq2keys:</span><br><span class="line">                        freq2keys[freq] = [key]</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        freq2keys[freq].append(key)</span><br><span class="line">                    <span class="comment"># 更新键频率</span></span><br><span class="line">                    key2freq[key] = freq</span><br><span class="line">                    <span class="comment"># 因为之前可能执行过删除操作，我们需要注意最小</span></span><br><span class="line">                    <span class="comment"># 频率那边还有没有元素，没有的话该元素为最小元素</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">len</span>(freq2keys[min_freq]) == <span class="number">0</span>:</span><br><span class="line">                        min_freq = freq</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 没有的话执行插入即可</span></span><br><span class="line">                    freq = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> freq <span class="keyword">not</span> <span class="keyword">in</span> freq2keys:</span><br><span class="line">                        freq2keys[freq] = [key]</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        freq2keys[freq].append(key)</span><br><span class="line">                    <span class="comment"># 更新键频率</span></span><br><span class="line">                    key2freq[key] = freq</span><br><span class="line">                    <span class="comment"># 更新最小频率</span></span><br><span class="line">                    min_freq = freq</span><br><span class="line">                    <span class="comment"># 更新键数量</span></span><br><span class="line">                    key_num += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 更新值</span></span><br><span class="line">                key2value[key] = value</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 这里是get操作</span></span><br><span class="line">                key = op[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> key <span class="keyword">in</span> key2value:</span><br><span class="line">                    <span class="comment"># 如果这个键是旧的，那需要更新一下优先级</span></span><br><span class="line">                    freq = key2freq[key]</span><br><span class="line">                    freq2keys[freq].remove(key)</span><br><span class="line">                    <span class="comment"># 更新入新数组</span></span><br><span class="line">                    freq = freq + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> freq <span class="keyword">not</span> <span class="keyword">in</span> freq2keys:</span><br><span class="line">                        freq2keys[freq] = [key]</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        freq2keys[freq].append(key)</span><br><span class="line">                    <span class="comment"># 更新键频率</span></span><br><span class="line">                    key2freq[key] = freq</span><br><span class="line">                    <span class="comment"># 因为之前可能执行过删除操作，我们需要注意最小</span></span><br><span class="line">                    <span class="comment"># 频率那边还有没有元素，没有的话该元素为最小元素</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">len</span>(freq2keys[min_freq]) == <span class="number">0</span>:</span><br><span class="line">                        min_freq = freq</span><br><span class="line">                </span><br><span class="line">                res.append(key2value.get(key, -<span class="number">1</span>))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h1 id="结语">结语</h1>
<p>到这里牛客的面试TOP101就做完了，感觉做完之后确实也有不小的收获，但是仍然感觉手比较生，有一些问题依旧是比较模糊。</p>
<p>但是后面马上要开题了，精力可能得往写开题报告上转移，可能也没太多时间写面试编程题了。<del>（再说找实习也并不顺利，投了简历半个多月没回应....）</del></p>
<p>后续（开题报告这阵子事忙完之后）可能我会回顾一下经典的NLP模型论文，尤其是大语言模型LLM路径上的一些关键模型的论文，比如BERT、RoBERTa、GPT、GPT3、T5、OPT、BLOOM、LLAMA等模型的论文，暂定这个系列为“朝花夕拾”吧。<del>（虽然没把握能写完，但先挂在这，以后写不完再想办法）</del></p>
<p>再之后是代码实现系列，我准备用《三国演义》作为语料，然后实现一个256词表大小的中文nanoGPT，致敬一下<a
target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=kCc8FmEb1nY">Andrej
Karpathy大佬的英文莎士比亚nanoGPT教程</a>，也作为GPT这样的Decoder only
transformer和自注意力机制的实现的训练。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://lisheng2001.github.io">LiSheng</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lisheng2001.github.io/2023/10/10/%E5%88%B7%E9%A2%98%E5%88%86%E4%BA%AB%EF%BC%9A%E6%88%91%E5%86%99%E7%89%9B%E5%AE%A2TOP101%E9%81%93%E7%BC%96%E7%A8%8B%E9%A2%98/">https://lisheng2001.github.io/2023/10/10/刷题分享：我写牛客TOP101道编程题/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lisheng2001.github.io" target="_blank">一世逍遥的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%88%B7%E7%BC%96%E7%A8%8B%E9%A2%98/">刷编程题</a></div><div class="post_share"><div class="social-share" data-image="/images/avatar.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/10/14/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94Transformer/" title="朝花夕拾（一）——Transformer"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">朝花夕拾（一）——Transformer</div></div></a></div><div class="next-post pull-right"><a href="/2023/10/07/%E5%88%A9%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%B0%86%E4%B8%8D%E5%90%8C%E8%AF%B4%E8%AF%9D%E4%BA%BA%E4%BB%8E%E9%9F%B3%E9%A2%91%E4%B8%AD%E5%88%86%E7%A6%BB/" title="利用深度学习将不同说话人从音频中分离"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">利用深度学习将不同说话人从音频中分离</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/08/20/20230820%E5%88%B7%E9%A2%98%E8%BF%91%E5%86%B5/" title="20230820刷题近况"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-20</div><div class="title">20230820刷题近况</div></div></a></div><div><a href="/2023/08/19/20230819%E5%88%B7%E9%A2%98%E8%BF%91%E5%86%B5/" title="20230819刷题近况"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-19</div><div class="title">20230819刷题近况</div></div></a></div><div><a href="/2023/08/23/20230823%E5%88%B7%E9%A2%98%E8%BF%91%E5%86%B5/" title="20230823刷题近况"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-23</div><div class="title">20230823刷题近况</div></div></a></div><div><a href="/2023/08/22/20230821%E5%88%B7%E9%A2%98%E8%BF%91%E5%86%B5/" title="20230821刷题近况"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-22</div><div class="title">20230821刷题近况</div></div></a></div><div><a href="/2023/08/25/20230825%E5%88%B7%E9%A2%98%E8%BF%91%E5%86%B5/" title="20230825刷题近况"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-25</div><div class="title">20230825刷题近况</div></div></a></div><div><a href="/2023/09/08/20230908%E5%88%B7%E9%A2%98%E8%BF%91%E5%86%B5/" title="20230908刷题近况"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-08</div><div class="title">20230908刷题近况</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="utterances-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/avatar.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">LiSheng</div><div class="author-info__description">也无风雨也无晴</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">51</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">71</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/LiSheng2001"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%8820%E6%97%A5"><span class="toc-number">1.</span> <span class="toc-text">9月20日</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#bm-55-%E6%B2%A1%E6%9C%89%E9%87%8D%E5%A4%8D%E9%A1%B9%E6%95%B0%E5%AD%97%E7%9A%84%E5%85%A8%E6%8E%92%E5%88%97"><span class="toc-number">1.1.</span> <span class="toc-text">BM 55 没有重复项数字的全排列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bm-56-%E6%9C%89%E9%87%8D%E5%A4%8D%E9%A1%B9%E7%9A%84%E5%85%A8%E6%8E%92%E5%88%97"><span class="toc-number">1.2.</span> <span class="toc-text">BM 56 有重复项的全排列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bm-57-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F"><span class="toc-number">1.3.</span> <span class="toc-text">BM 57 岛屿数量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bm-58-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97"><span class="toc-number">1.4.</span> <span class="toc-text">BM 58 字符串的排列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bm-59-n%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98"><span class="toc-number">1.5.</span> <span class="toc-text">BM 59 N皇后问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bm-60-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90"><span class="toc-number">1.6.</span> <span class="toc-text">BM 60 括号生成</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%8821%E6%97%A5"><span class="toc-number">2.</span> <span class="toc-text">9月21日</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#bm-61-%E7%9F%A9%E9%98%B5%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E8%B7%AF%E5%BE%84"><span class="toc-number">2.1.</span> <span class="toc-text">BM 61 矩阵最长递增路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bm-62-%E6%96%90%E6%B3%A2%E6%8B%89%E5%A5%91%E6%95%B0%E5%88%97"><span class="toc-number">2.2.</span> <span class="toc-text">BM 62 斐波拉契数列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bm-63-%E8%B7%B3%E5%8F%B0%E9%98%B6"><span class="toc-number">2.3.</span> <span class="toc-text">BM 63 跳台阶</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bm-64-%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="toc-number">2.4.</span> <span class="toc-text">BM 64 最小花费爬楼梯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bm-65-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%E4%BA%8C"><span class="toc-number">2.5.</span> <span class="toc-text">BM 65 最长公共子序列（二）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bm-66-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2"><span class="toc-number">2.6.</span> <span class="toc-text">BM 66 最长公共子串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bm-67-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%E7%9A%84%E6%95%B0%E7%9B%AE%E4%B8%80"><span class="toc-number">2.7.</span> <span class="toc-text">BM 67 不同路径的数目（一）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%8822%E6%97%A5"><span class="toc-number">3.</span> <span class="toc-text">9月22日</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#bm-68-%E7%9F%A9%E9%98%B5%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="toc-number">3.1.</span> <span class="toc-text">BM 68 矩阵最小路径和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bm-69-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">3.2.</span> <span class="toc-text">BM 69 把数字翻译成字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bm-70-%E5%85%91%E6%8D%A2%E9%9B%B6%E9%92%B1%E4%B8%80"><span class="toc-number">3.3.</span> <span class="toc-text">BM 70 兑换零钱（一）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bm-71-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E4%B8%80"><span class="toc-number">3.4.</span> <span class="toc-text">BM 71 最长上升子序列（一）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bm-72-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C"><span class="toc-number">3.5.</span> <span class="toc-text">BM 72 连续子数组的最大和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bm-73-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">3.6.</span> <span class="toc-text">BM 73 最长回文字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bm-74-%E6%95%B0%E5%AD%97%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E5%8C%96%E6%88%90ip%E5%9C%B0%E5%9D%80"><span class="toc-number">3.7.</span> <span class="toc-text">BM 74 数字字符串转化成IP地址</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%8823%E6%97%A5"><span class="toc-number">4.</span> <span class="toc-text">9月23日</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#bm-75-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%E4%B8%80"><span class="toc-number">4.1.</span> <span class="toc-text">BM 75 编辑距离（一）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%8825%E6%97%A5"><span class="toc-number">5.</span> <span class="toc-text">9月25日</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#bm-76-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="toc-number">5.1.</span> <span class="toc-text">BM 76 正则表达式匹配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bm-77-%E6%9C%80%E9%95%BF%E7%9A%84%E6%8B%AC%E5%8F%B7%E5%AD%90%E4%B8%B2"><span class="toc-number">5.2.</span> <span class="toc-text">BM 77 最长的括号子串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bm-78-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E4%B8%80"><span class="toc-number">5.3.</span> <span class="toc-text">BM 78 打家劫舍（一）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bm-79-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E4%BA%8C"><span class="toc-number">5.4.</span> <span class="toc-text">BM 79 打家劫舍（二）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%8826%E6%97%A5"><span class="toc-number">6.</span> <span class="toc-text">9月26日</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#bm-80-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A5%BD%E6%97%B6%E6%9C%BA%E4%B8%80"><span class="toc-number">6.1.</span> <span class="toc-text">BM 80 买卖股票的最好时机（一）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bm-81-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A5%BD%E6%97%B6%E6%9C%BA%E4%BA%8C"><span class="toc-number">6.2.</span> <span class="toc-text">BM 81 买卖股票的最好时机（二）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bm-82%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A5%BD%E6%97%B6%E6%9C%BA%E4%B8%89"><span class="toc-number">6.3.</span> <span class="toc-text">BM 82买卖股票的最好时机（三）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bm-83-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%98%E5%BD%A2"><span class="toc-number">6.4.</span> <span class="toc-text">BM 83 字符串变形</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bm-84-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80"><span class="toc-number">6.5.</span> <span class="toc-text">BM 84 最长公共前缀</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bm-85-%E9%AA%8C%E8%AF%81ip%E5%9C%B0%E5%9D%80"><span class="toc-number">6.6.</span> <span class="toc-text">BM 85 验证IP地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bm-86-%E5%A4%A7%E6%95%B0%E5%8A%A0%E6%B3%95"><span class="toc-number">6.7.</span> <span class="toc-text">BM 86 大数加法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bm-87-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E7%9A%84%E6%95%B0%E7%BB%84"><span class="toc-number">6.8.</span> <span class="toc-text">BM 87 合并两个有序的数组</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%8828%E6%97%A5"><span class="toc-number">7.</span> <span class="toc-text">9月28日</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#bm-88-%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">7.1.</span> <span class="toc-text">BM 88 判断是否为回文字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bm-89-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4"><span class="toc-number">7.2.</span> <span class="toc-text">BM 89 合并区间</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%882%E6%97%A5"><span class="toc-number">8.</span> <span class="toc-text">10月2日</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#bm-90-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2"><span class="toc-number">8.1.</span> <span class="toc-text">BM 90 最小覆盖子串</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%886%E6%97%A5"><span class="toc-number">9.</span> <span class="toc-text">10月6日</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#bm-90-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2-1"><span class="toc-number">9.1.</span> <span class="toc-text">BM 90 最小覆盖子串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bm-91-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">9.2.</span> <span class="toc-text">BM 91 反转字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bm-92-%E6%9C%80%E9%95%BF%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">9.3.</span> <span class="toc-text">BM 92 最长无重复子数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bm-93-%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-number">9.4.</span> <span class="toc-text">BM 93 盛水最多的容器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%889%E6%97%A5"><span class="toc-number">10.</span> <span class="toc-text">10月9日</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#bm-94-%E6%8E%A5%E9%9B%A8%E6%B0%B4%E9%97%AE%E9%A2%98"><span class="toc-number">10.1.</span> <span class="toc-text">BM 94 接雨水问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bm-95-%E5%88%86%E7%B3%96%E6%9E%9C%E9%97%AE%E9%A2%98"><span class="toc-number">10.2.</span> <span class="toc-text">BM 95 分糖果问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bm-96-%E4%B8%BB%E6%8C%81%E4%BA%BA%E8%B0%83%E5%BA%A6%E4%BA%8C"><span class="toc-number">10.3.</span> <span class="toc-text">BM 96 主持人调度（二）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bm-97-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84"><span class="toc-number">10.4.</span> <span class="toc-text">BM 97 旋转数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bm-98-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5"><span class="toc-number">10.5.</span> <span class="toc-text">BM 98 螺旋矩阵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bm-99-%E9%A1%BA%E6%97%B6%E9%92%88%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5"><span class="toc-number">10.6.</span> <span class="toc-text">BM 99 顺时针旋转矩阵</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%8810%E6%97%A5"><span class="toc-number">11.</span> <span class="toc-text">10月10日</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#bm-100-%E8%AE%BE%E8%AE%A1lru%E7%BC%93%E5%AD%98"><span class="toc-number">11.1.</span> <span class="toc-text">BM 100 设计LRU缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bm-101-%E8%AE%BE%E8%AE%A1lfu%E7%BC%93%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-number">11.2.</span> <span class="toc-text">BM 101 设计LFU缓存结构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E8%AF%AD"><span class="toc-number">12.</span> <span class="toc-text">结语</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/28/%E4%BB%8E3%E7%AF%87%E8%AE%BA%E6%96%87%E5%9B%9E%E9%A1%BE2024%E5%B9%B4%E5%9F%BA%E7%A1%80%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%BF%9B%E5%B1%95/" title="从3篇论文回顾2024年基础大语言模型的进展">从3篇论文回顾2024年基础大语言模型的进展</a><time datetime="2025-03-28T13:03:49.000Z" title="发表于 2025-03-28 21:03:49">2025-03-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/27/%E8%AF%84%E4%BC%B0LLM%E4%B9%8B%E5%9C%A824%E5%B9%B4%E7%9A%84%E7%AE%A1%E7%90%86%E7%B1%BB%E8%81%94%E8%80%83%E9%80%BB%E8%BE%91%E9%80%89%E6%8B%A9%E9%A2%98%E8%AF%84%E4%BC%B0/" title="评估LLM之在24年的管理类联考逻辑选择题评估">评估LLM之在24年的管理类联考逻辑选择题评估</a><time datetime="2025-01-27T08:33:07.000Z" title="发表于 2025-01-27 16:33:07">2025-01-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/23/%E5%9C%A8hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%8F%92%E5%85%A5echarts%E5%9B%BE%E8%A1%A8/" title="在hexo博客中插入echarts图表">在hexo博客中插入echarts图表</a><time datetime="2025-01-23T03:59:36.000Z" title="发表于 2025-01-23 11:59:36">2025-01-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/06/huggingface%E4%B8%ADDatasets%E6%A8%A1%E5%9D%97%E7%9A%84%E7%AC%94%E8%AE%B0/" title="huggingface中Datasets模块的笔记">huggingface中Datasets模块的笔记</a><time datetime="2025-01-06T12:43:34.000Z" title="发表于 2025-01-06 20:43:34">2025-01-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/04/LLM%E8%AF%84%E4%BC%B0/" title="LLM评估">LLM评估</a><time datetime="2025-01-04T12:45:23.000Z" title="发表于 2025-01-04 20:45:23">2025-01-04</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By LiSheng</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script>function runPanguForPostContent() {
  const postContent = document.querySelector('.post-content');

  if (postContent) {
    pangu.spacingNode(postContent); // 只处理文章内容区域
  }
}

function panguFn() {
  if (typeof pangu === 'object') {
    runPanguForPostContent();
  } else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        runPanguForPostContent();
      });
  }
}

function panguInit() {
  if (false) {
    GLOBAL_CONFIG_SITE.isPost && panguFn();
  } else {
    panguFn();
  }
}

document.addEventListener('DOMContentLoaded', panguInit);</script><div class="js-pjax"><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
  }

  btf.addModeChange('mermaid', runMermaid)

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>function loadUtterances () {
  let ele = document.createElement('script')
  ele.setAttribute('id', 'utterances_comment')
  ele.setAttribute('src', 'https://utteranc.es/client.js')
  ele.setAttribute('repo', 'LiSheng2001/LiSheng2001.github.io')
  ele.setAttribute('issue-term', 'pathname')
  let nowTheme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'photon-dark' : 'github-light'
  ele.setAttribute('theme', nowTheme)
  ele.setAttribute('crossorigin', 'anonymous')
  ele.setAttribute('async', 'true')
  document.getElementById('utterances-wrap').insertAdjacentElement('afterbegin',ele)
}

function utterancesTheme (theme) {
  const iframe = document.querySelector('.utterances-frame')
  if (iframe) {
    const theme = theme === 'dark' ? 'photon-dark' : 'github-light'
    const message = {
      type: 'set-theme',
      theme: theme
    };
    iframe.contentWindow.postMessage(message, 'https://utteranc.es');
  }
}

btf.addModeChange('utterances', utterancesTheme)

if ('Utterances' === 'Utterances' || !true) {
  if (true) btf.loadComment(document.getElementById('utterances-wrap'), loadUtterances)
  else loadUtterances()
} else {
  function loadOtherComment () {
    loadUtterances()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>